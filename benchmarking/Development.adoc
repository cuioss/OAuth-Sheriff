= Benchmark Development Guide
:toc: left
:toclevels: 2

== Adding Library Benchmarks

=== Using the Existing Infrastructure

Library benchmarks extend `AbstractBenchmark` which provides:

[source,java]
----
public class MyBenchmark extends AbstractBenchmark {
    
    // Inherited from AbstractBenchmark:
    // - tokenRepository: MockTokenRepository with 600 test tokens
    // - tokenValidator: Configured TokenValidator with performance monitoring
    
    @Setup(Level.Trial)
    public void setup() {
        setupBase();  // Initializes token repository and validator
        // Your additional setup here
    }
}
----

=== Using the Delegate Pattern

The project uses delegates to organize benchmark logic:

[source,java]
----
// Create a delegate for your benchmark logic
public class MyValidationDelegate extends BenchmarkDelegate {
    
    private final AtomicInteger tokenIndex = new AtomicInteger(0);
    
    public MyValidationDelegate(TokenValidator validator, MockTokenRepository repository) {
        super(validator, repository);
    }
    
    public AccessTokenContent validateWithRotation() {
        // Rotate through token pool
        String token = tokenRepository.getToken(tokenIndex.getAndIncrement());
        return validateToken(token);
    }
}

// Use in your benchmark
public class MyBenchmark extends AbstractBenchmark {
    private MyValidationDelegate delegate;
    
    @Setup(Level.Trial)
    public void setup() {
        setupBase();
        delegate = new MyValidationDelegate(tokenValidator, tokenRepository);
    }
    
    @Benchmark
    public AccessTokenContent measureValidation() {
        return delegate.validateWithRotation();
    }
}
----

=== Token Repository Patterns

The `MockTokenRepository` provides 600 pre-generated tokens:

[source,java]
----
// Access tokens by index (0-599)
String token = tokenRepository.getToken(index);

// Get issuer configuration
IssuerConfig issuer = tokenRepository.getIssuerConfig();

// Token rotation for cache testing
int index = counter.getAndIncrement() % tokenRepository.getTokenPoolSize();
String rotatingToken = tokenRepository.getToken(index);
----

=== Error Scenario Testing

For error scenarios, use the test token generators:

[source,java]
----
public class ErrorBenchmark extends AbstractBenchmark {
    
    private List<TestTokenHolder> errorTokens;
    
    @Setup
    public void setup() {
        setupBase();
        
        errorTokens = Arrays.asList(
            TestTokenGenerators.generateExpiredToken(),
            TestTokenGenerators.generateMalformedToken(),
            TestTokenGenerators.generateInvalidSignatureToken()
        );
    }
    
    @Benchmark
    public void measureErrorHandling() {
        for (TestTokenHolder token : errorTokens) {
            try {
                tokenValidator.validate(token.getTokenString());
            } catch (TokenValidationException expected) {
                // Expected error, part of benchmark
            }
        }
    }
}
----

== Adding Integration Benchmarks

=== Using AbstractIntegrationBenchmark

Integration benchmarks test against a running Quarkus instance:

[source,java]
----
public class MyEndpointBenchmark extends AbstractIntegrationBenchmark {
    
    // Inherited:
    // - httpClient: Configured HTTP client
    // - tokenRepository: KeycloakTokenRepository with real tokens
    // - baseUrl: From system properties
    
    @Benchmark
    public void measureEndpoint() throws Exception {
        // Get a valid token from repository
        String token = tokenRepository.getValidToken();
        
        // Create authenticated request
        HttpRequest request = createAuthenticatedRequest("/api/endpoint", token)
            .POST(HttpRequest.BodyPublishers.ofString("{\"data\":\"test\"}"))
            .build();
        
        // Send and validate
        HttpResponse<String> response = sendRequest(request);
        validateResponse(response, 200);
    }
}
----

=== Token Repository in Integration Tests

Integration benchmarks use `KeycloakTokenRepository`:

[source,java]
----
// Get valid tokens
String validToken = tokenRepository.getValidToken();

// Rotate through token pool
String rotatingToken = tokenRepository.getTokenAtIndex(index++ % tokenRepository.getTokenPoolSize());

// Token repository is configured via properties:
// - keycloak.url
// - keycloak.realm
// - keycloak.client-id
// - keycloak.client-secret
----

== Benchmark Patterns in This Project

=== Full Spectrum Testing
Tests cache effectiveness by rotating through all available tokens:

[source,java]
----
public AccessTokenContent validateWithFullSpectrum() {
    // Rotates through entire 600-token pool
    String token = tokenRepository.getToken(tokenIndex.getAndIncrement());
    return validateToken(token);
}
----

=== Concurrent Validation Pattern
Tests multi-threaded performance:

[source,java]
----
@State(Scope.Thread)  // Thread-local state
public class ConcurrentBenchmark extends AbstractBenchmark {
    
    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    @Threads(4)  // Explicit thread count
    public AccessTokenContent measureConcurrent() {
        return delegate.validateWithRotation();
    }
}
----

=== Metrics Export
Benchmarks automatically export metrics via `SimplifiedMetricsExporter`:

[source,java]
----
@TearDown(Level.Trial)
public void exportBenchmarkMetrics() {
    // Automatically called by AbstractBenchmark
    // Exports to target/benchmark-results/
    SimplifiedMetricsExporter.exportMetrics(tokenValidator.getPerformanceMonitor());
}
----

== Running Benchmarks

=== Quick Development Run
[source,bash]
----
# Minimal run for development (1 fork, 1 iteration)
./mvnw clean verify -Pbenchmark -pl benchmarking/benchmark-library \
  -Djmh.f=1 -Djmh.wi=1 -Djmh.i=1

# Run specific benchmark class
./mvnw clean verify -Pbenchmark -pl benchmarking/benchmark-library \
  -Djmh.includes="SimpleCoreValidationBenchmark"
----

=== Integration Benchmark Setup
[source,bash]
----
# 1. Start Quarkus (required for integration benchmarks)
cd cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
./mvnw quarkus:dev

# 2. Run integration benchmarks
./mvnw clean verify -Pbenchmark -pl benchmarking/benchmark-integration-quarkus
----

=== Output Files
- Library benchmarks: `benchmark-library/target/benchmark-results/micro-result.json`
- Integration benchmarks: `benchmark-integration-quarkus/target/benchmark-results/integration-result.json`
- Metrics export: `target/benchmark-results/metrics-*.json`

== Configuration

=== System Properties
[source,bash]
----
# JMH configuration
-Djmh.f=2          # Forks
-Djmh.wi=3         # Warmup iterations
-Djmh.i=5          # Measurement iterations
-Djmh.t=1          # Threads

# Integration test configuration
-Dquarkus.url=http://localhost:8080
-Dkeycloak.url=http://localhost:8080/auth
----

=== MockTokenRepository Configuration
[source,java]
----
MockTokenRepository.Config config = MockTokenRepository.Config.builder()
    .cacheSize(60)      // 10% of 600 tokens
    .tokenPoolSize(600) // Total tokens in pool
    .build();
----

== Common Pitfalls and Solutions

=== Token Index Overflow
[source,java]
----
// Wrong - will overflow
String token = tokenRepository.getToken(counter.getAndIncrement());

// Correct - use modulo
int index = counter.getAndIncrement() % tokenRepository.getTokenPoolSize();
String token = tokenRepository.getToken(index);
----

=== Missing Base Setup
[source,java]
----
// Wrong - forgot base setup
@Setup
public void setup() {
    myDelegate = new MyDelegate(tokenValidator, tokenRepository);
    // NullPointerException - tokenValidator not initialized!
}

// Correct - call setupBase first
@Setup
public void setup() {
    setupBase();  // MUST call this first
    myDelegate = new MyDelegate(tokenValidator, tokenRepository);
}
----

=== Integration Test Connection
[source,java]
----
// Check Quarkus is running before benchmarks
@Setup
public void verifyConnection() {
    try {
        HttpResponse<String> health = httpClient.send(
            HttpRequest.newBuilder()
                .uri(URI.create(baseUrl + "/health"))
                .GET().build(),
            HttpResponse.BodyHandlers.ofString());
        
        if (health.statusCode() != 200) {
            throw new IllegalStateException("Quarkus not responding");
        }
    } catch (Exception e) {
        throw new IllegalStateException("Cannot connect to Quarkus", e);
    }
}
----