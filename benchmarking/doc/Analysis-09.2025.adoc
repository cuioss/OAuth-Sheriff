= Resource Monitoring Enhancement Analysis - September 2025
:source-highlighter: highlight.js

Analysis of benchmark infrastructure enhancements to support comprehensive CPU and RAM utilization monitoring across different benchmark types.

== Overview

This analysis documents the implementation of resource monitoring capabilities for both JMH-based Quarkus benchmarks and WRK-based load testing benchmarks, providing comprehensive CPU and RAM utilization metrics comparison.

== Infrastructure Enhancements

=== Quarkus JMH Benchmark Enhancements

Enhanced the `QuarkusIntegrationRunner` to include JMH profilers for detailed JVM-level resource monitoring:

[source,java]
----
@Override
protected OptionsBuilder buildCommonOptions(BenchmarkConfiguration config) {
    OptionsBuilder builder = super.buildCommonOptions(config);

    // Add profilers for CPU and memory metrics collection
    builder.addProfiler("gc");       // GC statistics
    builder.addProfiler("stack");    // Hot method analysis
    builder.addProfiler("comp");     // JIT compilation tracking

    return builder;
}
----

=== WRK Benchmark System Monitoring

Implemented comprehensive system-level monitoring in the WRK benchmark script with cross-platform support:

[source,bash]
----
# Cross-platform system monitoring implementation
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS-specific monitoring using ps, vm_stat, memory_pressure
    CPU_PERCENT=$(ps -A -o %cpu | awk '{s+=$1} END {printf "%.1f", s}')
    MEMORY_PRESSURE=$(memory_pressure | grep "System-wide memory free percentage" | awk '{print $6}' | tr -d '%')
    MEMORY_PERCENT=$(echo "100 - $MEMORY_PRESSURE" | bc -l 2>/dev/null || echo "0")
else
    # Linux monitoring using /proc filesystem
    CPU_PERCENT=$(grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$3+$4+$5)} END {print usage}')
    MEMORY_PERCENT=$(free | grep Mem | awk '{printf("%.1f", $3/$2 * 100.0)}')
fi
----

== Benchmark Results Analysis

=== Performance Metrics Comparison

==== JWT Validation Performance

* **WRK Load Testing Results**:
** Throughput: 8,246.55 requests/sec
** Average Latency: 5.62ms
** 99th Percentile: 36.65ms
** Test Duration: 30 seconds with 4 threads, 20 connections

* **Quarkus JMH Results**:
** Throughput: 7,841 ops/sec
** 50th Percentile: 2.621µs (2,621 nanoseconds)
** 99th Percentile: 7.430µs (7,430 nanoseconds)

==== Health Check Performance

* **WRK Health Check**:
** Throughput: 14,616.74 requests/sec
** Average Latency: 827.59µs
** 99th Percentile: 3.36ms

* **Quarkus Health Check**:
** Throughput: 10,238 ops/sec
** 50th Percentile: 1.901µs
** 99th Percentile: 5.210µs

=== Resource Utilization Analysis

==== CPU and Memory Metrics

* **WRK System-Level Metrics**:
** CPU Utilization: 242.8% - 756.8% (multi-core system)
** Memory Usage: 15.1 - 81.9 MB system memory
** System Load Average: 6.60 - 8.71 (1-minute average)
** Process Count: 884-898 active processes

* **Quarkus JMH Profiler Metrics**:
** GC Allocation Rate: ~358 MB/sec
** Memory per Operation: ~36.7 KB per JWT validation
** GC Events: 122 collections during benchmark run
** Low GC overhead with efficient memory management

== Key Findings

=== Performance Characteristics

1. **Latency Differences**: JMH microsecond-level measurements vs. WRK millisecond HTTP round-trip times
2. **Throughput Comparison**: Similar ranges (7K-8K ops/sec for JWT validation) but different measurement contexts
3. **Health Check Efficiency**: Both show health endpoints significantly outperform JWT validation

=== Resource Monitoring Insights

1. **Monitoring Approaches**:
   - **WRK**: System-level monitoring showing external load impact
   - **Quarkus**: JVM-internal profiling revealing allocation patterns

2. **CPU Usage Patterns**:
   - **WRK**: High multi-core utilization due to external HTTP requests
   - **Quarkus**: Focused JIT compilation and GC activity analysis

3. **Memory Characteristics**:
   - **WRK**: System memory pressure from concurrent connections
   - **Quarkus**: Detailed allocation patterns (36.7 KB per operation)

=== Cross-Platform Compatibility

The enhanced monitoring infrastructure supports both macOS and Linux environments with platform-specific optimizations:

* **macOS**: Uses `ps`, `vm_stat`, `memory_pressure` commands
* **Linux**: Leverages `/proc` filesystem for efficient metrics collection

== Technical Implementation

=== JMH Profiler Integration

The GC, stack, and compilation profilers provide comprehensive JVM insights:

* **GC Profiler**: Tracks allocation rates, collection frequency, and memory efficiency
* **Stack Profiler**: Identifies hot methods and call patterns
* **Compiler Profiler**: Monitors JIT compilation activity and optimization

=== System Monitoring Implementation

Cross-platform shell script implementation collecting:

* CPU utilization across all cores
* Memory usage and pressure indicators
* System load averages
* Process counts and resource contention

== Conclusions

The enhanced benchmark infrastructure successfully provides complementary resource monitoring capabilities:

1. **JMH Profiling** offers deep JVM-level insights into memory allocation and garbage collection patterns
2. **System Monitoring** captures external load impact and overall system resource utilization
3. **Cross-Platform Support** ensures consistent monitoring across development and deployment environments
4. **Performance Validation** confirms efficient JWT validation with reasonable resource consumption

This dual-approach monitoring provides comprehensive visibility into both internal JVM efficiency and external system impact, enabling thorough performance analysis and optimization opportunities.

== Recommendations

1. **Continue JMH profiling** for internal optimization insights
2. **Maintain system monitoring** for deployment and scaling decisions
3. **Regular comparison analysis** to ensure performance consistency
4. **Consider memory allocation optimization** based on the 36.7 KB per operation finding