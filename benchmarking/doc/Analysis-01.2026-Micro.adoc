= JWT Library Performance Analysis (Micro-Benchmarks)
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js


== Executive Summary

JMH micro-benchmark testing of the core JWT validation library shows:

* **Core Validation**: 159,100 ops/s (in-memory, no HTTP overhead)
* **Error Handling (0% errors)**: 152,200 ops/s (validation succeeds)
* **Error Handling (50% errors)**: 222,300 ops/s (fast-fail on invalid tokens)
* **Validation Latency**: P50=77µs, P95=80µs, P99=163µs
* **Signature Validation**: P50=68µs (dominant cost in validation pipeline)
* **Library Performance**: 7x faster than integration tests (159k vs 23k ops/s)

== JMH Benchmark Configuration

=== Test Environment

* **Tool**: JMH 1.37 (Java Microbenchmark Harness)
* **JVM**: OpenJDK 21.0.7 (Temurin), aarch64 (Apple M4)
* **Threads**: 100 concurrent threads
* **Iterations**: 5 measurement + 3 warmup
* **Duration**: 4 seconds per iteration
* **Mode**: Throughput (ops/s) and Average Time (µs/op)

=== Benchmark Suite

[cols="2,3", options="header"]
|===
|Benchmark
|Description

|SimpleCoreValidationBenchmark
|Core JWT validation performance (throughput and latency)

|SimpleErrorLoadBenchmark
|Error handling with 0% and 50% invalid token rates

|jwt-validation-metrics
|Detailed breakdown of validation pipeline steps
|===

== Performance Results

=== Throughput Benchmarks

[cols="2,2,2,2", options="header"]
|===
|Benchmark
|Throughput
|Latency (avg)
|Configuration

|Core Validation
|159,100 ops/s
|657 µs/op
|100 threads, valid tokens

|Error Load (0% errors)
|152,200 ops/s
|N/A
|100 threads, all valid

|Error Load (50% errors)
|222,300 ops/s
|N/A
|100 threads, 50% invalid

|Concurrent Validation
|N/A
|648 µs/op
|100 threads, concurrent
|===

**Key Findings:**

* **Error handling improves throughput**: Fast-fail on invalid tokens (50% error rate) achieves 222k ops/s (+39% vs baseline)
* **All-valid scenario**: 152k ops/s when all tokens are valid (-4% vs core validation)
* **Latency consistency**: 648-657µs average time across different concurrency patterns

=== Validation Pipeline Breakdown

Based on `jwt-validation-metrics.json` (1,024 samples):

[cols="2,2,2,2", options="header"]
|===
|Step
|P50 Latency
|P95 Latency
|P99 Latency

|**Complete Validation**
|**77 µs**
|**80 µs**
|**163 µs**

|Signature Validation
|68 µs
|69 µs
|151 µs

|Token Parsing
|4.3 µs
|5.1 µs
|6.7 µs

|Token Building
|2.8 µs
|3.5 µs
|4.1 µs

|Claims Validation
|1.0 µs
|1.3 µs
|1.5 µs

|Cache Lookup
|0.1 µs
|0.4 µs
|0.7 µs

|Cache Store
|0.1 µs
|0.5 µs
|0.7 µs

|Issuer Config Resolution
|0.0 µs
|0.2 µs
|0.3 µs

|Issuer Extraction
|0.0 µs
|0.2 µs
|0.3 µs

|Header Validation
|0.1 µs
|0.3 µs
|0.3 µs
|===

**Analysis:**

* **Signature validation dominates**: 68µs (88% of total 77µs) - cryptographic operations are the bottleneck
* **Parsing overhead**: 4.3µs (6%) - JSON parsing and token extraction
* **Cache efficiency**: 0.1µs - lock-free cache adds negligible overhead
* **Claims validation**: 1.0µs - audience, expiration, issuer checks are fast
* **Total overhead**: ~9µs for non-cryptographic operations (parsing, claims, cache, issuer resolution)

== Performance Analysis

=== Library vs Integration Performance Gap

**Observation:** Library micro-benchmarks achieve 159k ops/s while integration tests (WRK) show 23k ops/s.

**Gap Analysis:**

[cols="2,3", options="header"]
|===
|Metric
|Measurement

|Pure library (micro-benchmark)
|159,100 ops/s, 77µs P50 latency

|Integration (WRK, 150 conns stress)
|23,800 ops/s, 5.49ms P50 latency

|Throughput gap
|7x slower (135k ops/s difference)

|Latency gap
|71x slower (5.413ms overhead)

|Integration overhead includes
|HTTP/REST stack, Docker networking, CDI context, serialization (individual contributions unmeasured)
|===

**Conclusion:** The core library validation is highly optimized at 159k ops/s with 77µs latency. Integration testing shows 23k ops/s and 5.49ms latency - the 5.413ms overhead includes HTTP/REST framework stack components (individual contributions unmeasured).

=== Bottleneck Identification

**Primary Bottleneck: Cryptographic Signature Validation**

* **Signature validation**: 68µs P50 (88% of validation time)
* **Algorithm**: RSA-256 signature verification (asymmetric cryptography)
* **Not optimizable**: Cryptographic operations are computationally intensive by design

**Secondary Costs:**

1. **Token parsing**: 4.3µs (JSON deserialization)
2. **Object construction**: 2.8µs (AccessTokenContent building)
3. **Claims validation**: 1.0µs (date checks, audience, issuer)
4. **Cache operations**: 0.1µs (negligible with lock-free design)

=== Error Handling Performance

**Fast-Fail Optimization:**

* **50% invalid tokens**: 222k ops/s (+39% throughput)
* **Early rejection**: Invalid tokens fail at signature validation without full parsing
* **Production benefit**: Real-world scenarios with invalid tokens see improved throughput

**Error Distribution:**

* Expired tokens: Detected in claims validation (1.0µs)
* Invalid signatures: Fail at signature validation (68µs)
* Malformed tokens: Fail at parsing (4.3µs)

== Comparison: Micro vs Integration

[cols="2,2,2,3", options="header"]
|===
|Metric
|Micro (Library)
|Integration (WRK)
|Difference

|Throughput
|159,100 ops/s
|22,700 ops/s
|**7x faster** (library)

|Latency P50
|77 µs
|5,490 µs
|**71x faster** (library)

|Latency P99
|163 µs
|32,590 µs
|**200x faster** (library)

|Environment
|In-memory JMH
|HTTP/Docker/Quarkus
|Network + framework overhead
|===

**Key Takeaway:** The core library is extremely fast (77µs P50). Integration overhead (HTTP, REST framework) adds ~5.4ms, which is acceptable for real-world HTTP-based microservices.

== Conclusion

Comprehensive JMH micro-benchmark analysis reveals:

* **Excellent library performance**: 159k ops/s with 77µs P50 latency demonstrates highly optimized JWT validation
* **Signature validation dominates**: 88% of validation time (68µs) spent in cryptographic operations (expected and unavoidable)
* **Minimal overhead**: Non-cryptographic operations (parsing, cache, claims) add only ~9µs (12% of total)
* **Fast-fail optimization**: 50% invalid token rate improves throughput to 222k ops/s
* **Integration reality check**: 7x throughput gap (159k ops/s library vs 23k ops/s integration) and 71x latency gap (77µs vs 5.49ms) - integration includes HTTP/REST framework stack (individual contributions unmeasured)
* **Production readiness**: Library meets performance requirements with sub-100µs validation latency

**Recommendation:** Current library performance is excellent. Further optimization would require algorithmic changes to signature validation (e.g., EdDSA instead of RSA), which is outside the scope of this library.
