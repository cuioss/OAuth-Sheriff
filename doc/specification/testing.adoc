= JWT Token Handling Testing
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

link:../Specification.adoc[Back to Main Specification]

== Overview
_See Requirement link:../Requirements.adoc#CUI-JWT-5[CUI-JWT-5: Testing Requirements]_

This document provides detailed specifications for testing the JWT token handling library.

== Compliance with CUI Testing Standards

This section outlines how the JWT token handling library testing should comply with the https://github.com/cuioss/cui-llm-rules/blob/main/standards/testing/core-standards.adoc[CUI Testing Core Standards].

=== Current Gaps and Implementation Plan

The following gaps have been identified between the current testing implementation and the CUI Testing Core Standards:

==== Test Coverage Gaps

* *Gap*: No explicit coverage target defined (CUI standard requires 80% line coverage)
* *Gap*: No explicit requirement for all public methods to have unit tests
* *Plan*: 
  ** Implement test coverage reporting in the build process
  ** Ensure all public methods have corresponding unit tests
  ** Set up coverage thresholds in the build to enforce minimum 80% line coverage

==== Test Independence Gaps

* *Gap*: No explicit guidelines for test independence
* *Gap*: No requirements for tests to clean up after themselves
* *Plan*:
  ** Review existing tests for independence issues
  ** Add guidelines for ensuring test independence
  ** Implement proper test cleanup mechanisms, especially for integration tests

==== Test Clarity Gaps

* *Gap*: No explicit guidelines for test naming
* *Gap*: No explicit mention of the Arrange-Act-Assert pattern
* *Plan*:
  ** Establish consistent test naming conventions
  ** Document and enforce the Arrange-Act-Assert pattern in all tests
  ** Add examples of well-structured tests

==== Test Maintenance Gaps

* *Gap*: No guidelines for maintaining tests alongside production code
* *Gap*: No requirements for promptly fixing failing tests
* *Plan*:
  ** Establish guidelines for test maintenance
  ** Implement CI/CD checks to prevent merging code with failing tests
  ** Document the process for updating tests when production code changes

==== Test Organization Gaps

* *Gap*: No guidelines for organizing tests
* *Gap*: No conventions for test method naming
* *Plan*:
  ** Establish a consistent structure for test classes
  ** Define naming conventions for test methods
  ** Group related tests in the same test class

==== Test Data Gaps

* *Gap*: No guidelines for test data management
* *Gap*: No recommendations for avoiding hardcoded values
* *Plan*:
  ** Create reusable test data generators
  ** Implement test data builders for complex objects
  ** Document best practices for test data management

==== Assertion Gaps

* *Gap*: No guidelines for using specific assertions
* *Gap*: No requirements for meaningful error messages
* *Plan*:
  ** Document best practices for assertions
  ** Ensure all assertions include meaningful error messages
  ** Use appropriate assertion methods for different scenarios

=== Production Code Considerations

While implementing the testing improvements outlined above, it's important to note that no production code should be modified unless absolutely necessary. The focus should be on enhancing the test suite and documentation without changing the core functionality.

However, during the testing improvements, some potential needs for production code changes might be identified:

1. *Testability Improvements*: Some classes might need minor refactoring to improve testability, such as:
   * Adding interfaces for better mocking
   * Extracting complex methods into smaller, more testable units
   * Adding package-private methods for testing purposes

2. *Logging Enhancements*: To support comprehensive logging tests, production code might need:
   * Consistent use of logging levels
   * Structured log messages with proper identifiers
   * Appropriate error handling with logging

3. *Performance Considerations*: To meet performance testing requirements, some optimizations might be needed:
   * Improved caching mechanisms
   * More efficient algorithms
   * Better resource management

Any such changes should be discussed with the team and implemented separately from the testing improvements, following proper change management procedures.

== Testing Strategy

=== Unit Testing
_See Requirement link:../Requirements.adoc#CUI-JWT-5.1[CUI-JWT-5.1: Unit Testing]_

Unit tests will cover:

1. Token parsing and validation
2. Key management and rotation
3. Multi-issuer support
4. Error handling
5. Edge cases (malformed tokens, expired tokens, etc.)

The following test classes implement these unit tests:

* link:../../src/test/java/de/cuioss/jwt/token/JwksAwareTokenParserImplTest.java[JwksAwareTokenParserImplTest.java] - Tests for the JWKS-aware token parser
* link:../../src/test/java/de/cuioss/jwt/token/ParsedTokenTest.java[ParsedTokenTest.java] - Tests for the ParsedToken base class
* link:../../src/test/java/de/cuioss/jwt/token/ParsedAccessTokenTest.java[ParsedAccessTokenTest.java] - Tests for the ParsedAccessToken class
* link:../../src/test/java/de/cuioss/jwt/token/ParsedIdTokenTest.java[ParsedIdTokenTest.java] - Tests for the ParsedIdToken class
* link:../../src/test/java/de/cuioss/jwt/token/ParsedRefreshTokenTest.java[ParsedRefreshTokenTest.java] - Tests for the ParsedRefreshToken class
* link:../../src/test/java/de/cuioss/jwt/token/TokenFactoryTest.java[TokenFactoryTest.java] - Tests for the TokenFactory
* link:../../src/test/java/de/cuioss/jwt/token/jwks/HttpJwksLoaderTest.java[HttpJwksLoaderTest.java] - Tests for the HTTP JWKS loader
* link:../../src/test/java/de/cuioss/jwt/token/jwks/FileJwksLoaderTest.java[FileJwksLoaderTest.java] - Tests for the file-based JWKS loader
* link:../../src/test/java/de/cuioss/jwt/token/jwks/InMemoryJwksLoaderTest.java[InMemoryJwksLoaderTest.java] - Tests for the in-memory JWKS loader

==== Test Cases

The following test cases will be implemented:

1. **Token Parsing Tests**:
   * Parse valid token
   * Parse token with invalid signature
   * Parse expired token
   * Parse token with missing claims
   * Parse token with unsupported algorithm

2. **Key Management Tests**:
   * Retrieve key by ID
   * Refresh keys
   * Handle key rotation
   * Handle key retrieval failures

3. **Multi-Issuer Tests**:
   * Parse tokens from different issuers
   * Handle unknown issuers
   * Select correct parser based on issuer

4. **Error Handling Tests**:
   * Handle malformed tokens
   * Handle network failures
   * Handle invalid keys

==== Example Test

[source,java]
----
@Test
void shouldParseValidToken() {
    // Given
    String token = createValidToken();

    // When
    Optional<ParsedToken> result = tokenFactory.createToken(token);

    // Then
    assertTrue(result.isPresent());
    assertEquals("test-subject", result.get().getSubject());
    assertEquals("test-issuer", result.get().getIssuer());
}

@Test
void shouldReturnEmptyForInvalidSignature() {
    // Given
    String token = createTokenWithInvalidSignature();

    // When
    Optional<ParsedToken> result = tokenFactory.createToken(token);

    // Then
    assertFalse(result.isPresent());
}
----

=== Integration Testing with TestContainers
_See Requirement link:../Requirements.adoc#CUI-JWT-5.2[CUI-JWT-5.2: Integration Testing]_

Integration tests will verify compatibility with identity providers (IDPs) that can be instrumented using TestContainers. Currently, Keycloak is the primary IDP that can be easily tested with TestContainers.

==== Keycloak Integration with TestContainers

The following test class implements integration tests with Keycloak using TestContainers:

* link:../../src/test/java/de/cuioss/jwt/token/TokenKeycloakITTest.java[TokenKeycloakITTest.java] - Integration tests with Keycloak

===== TestContainer Project Links

* Official Keycloak TestContainer: https://www.testcontainers.org/modules/keycloak/
* CUI Keycloak Integration: `de.cuioss.test:cui-test-keycloak-integration` (Maven dependency)

===== Test Cases

The following test cases are implemented for Keycloak:

* Parse access tokens from Keycloak
* Parse ID tokens from Keycloak
* Parse refresh tokens from Keycloak
* Validate tokens against Keycloak JWKS endpoint
* Handle token expiration and validation


The `KeycloakITBase` class from the `cui-test-keycloak-integration` library provides:

* Automatic setup and teardown of a Keycloak container
* Methods to get the Keycloak URLs (getIssuer(), getJWKSUrl(), getTokenUrl())
* Test realm and user configuration
* Helper methods for token requests and validation

=== Security Testing
_See Requirement link:../Requirements.adoc#CUI-JWT-8[CUI-JWT-8: Security Requirements]_

Security tests will include:

1. Token validation bypass tests
2. Algorithm confusion attack tests
3. Key disclosure vulnerability tests
4. Signature verification bypass tests
5. Token cracking resistance tests

==== Test Cases

The following test cases will be implemented:

1. **Algorithm Confusion Attack Tests**:
   * Test with "none" algorithm
   * Test with algorithm switching
   * Test with symmetric/asymmetric algorithm confusion

2. **Signature Verification Bypass Tests**:
   * Test with empty signature
   * Test with modified header
   * Test with modified payload but valid signature

3. **Key Disclosure Tests**:
   * Test for key information leakage
   * Test for private key protection

==== Example Test

[source,java]
----
@Test
void shouldRejectNoneAlgorithm() {
    // Given
    String tokenWithNoneAlgorithm = createTokenWithNoneAlgorithm();

    // When
    Optional<ParsedToken> result = tokenFactory.createToken(tokenWithNoneAlgorithm);

    // Then
    assertFalse(result.isPresent());
}

@Test
void shouldRejectAlgorithmSwitching() {
    // Given
    String tokenWithSwitchedAlgorithm = createTokenWithSwitchedAlgorithm();

    // When
    Optional<ParsedToken> result = tokenFactory.createToken(tokenWithSwitchedAlgorithm);

    // Then
    assertFalse(result.isPresent());
}
----

=== Performance Testing
_See Requirement link:../Requirements.adoc#CUI-JWT-5.3[CUI-JWT-5.3: Performance Testing]_

Performance tests will verify:

1. Token parsing performance (at least 1000 tokens per second)
2. Token validation performance (at least 500 tokens per second)
3. Key retrieval and caching performance (no more than 100ms overhead per new key)

==== Test Cases

The following test cases will be implemented:

1. **Token Parsing Performance Tests**:
   * Parse 10,000 tokens and measure throughput
   * Measure average parsing time per token

2. **Token Validation Performance Tests**:
   * Validate 10,000 tokens and measure throughput
   * Measure average validation time per token

3. **Key Retrieval Performance Tests**:
   * Measure key retrieval time
   * Measure key caching effectiveness

==== Example Test

[source,java]
----
@Test
void shouldMeetTokenParsingPerformanceRequirements() {
    // Given
    int numTokens = 10000;
    List<String> tokens = createTokens(numTokens);

    // When
    long startTime = System.currentTimeMillis();
    for (String token : tokens) {
        tokenFactory.createToken(token);
    }
    long endTime = System.currentTimeMillis();

    // Then
    long durationMs = endTime - startTime;
    double tokensPerSecond = numTokens / (durationMs / 1000.0);

    assertTrue(tokensPerSecond >= 1000, 
        "Token parsing performance should be at least 1000 tokens per second, but was " + tokensPerSecond);
}
----

=== Logging Tests
_See Requirement link:../Requirements.adoc#CUI-JWT-7[CUI-JWT-7: Logging Requirements]_

Logging tests will follow CUI logging test requirements:

1. Use `cui-test-juli-logger` for testing
2. Use `de.cuioss.test.juli.TestLogLevel` for log levels
3. Test coverage required for INFO/WARN/ERROR/FATAL logs
4. Follow LogAsserts guidelines:
   * First argument must be TestLogLevel
   * Only assertNoLogMessagePresent needs Logger parameter
   * Use appropriate assertion methods:
     * assertLogMessagePresent: Exact match
     * assertLogMessagePresentContaining: Partial match
     * assertNoLogMessagePresent: Absence check
     * assertSingleLogMessagePresent: Single occurrence
5. Test both successful and error scenarios
6. Use LogRecord#resolveIdentifierString for message verification

==== Test Cases

The following test cases will be implemented:

1. **Success Scenario Logging Tests**:
   * Test logging of successful token validation
   * Test logging of successful key retrieval
   * Test logging of successful token creation

2. **Error Scenario Logging Tests**:
   * Test logging of token validation failures
   * Test logging of key retrieval failures
   * Test logging of token creation failures

==== Example Test

[source,java]
----
@Test
void shouldLogTokenValidationSuccess() {
    // Given
    String issuer = "https://auth.example.com";
    String tokenString = createValidToken(issuer);

    // When
    tokenParser.parseToken(tokenString);

    // Then
    LogAsserts.assertLogMessagePresentContaining(
        TestLogLevel.INFO,
        JwtTokenLogMessages.INFO.TOKEN_VALIDATED.resolveIdentifierString());
}

@Test
void shouldLogKeyRetrievalFailure() {
    // Given
    String endpoint = "https://invalid-endpoint.example.com";

    // When
    try {
        jwksLoader.getKey("invalid-key-id"); // This will trigger a refresh
    } catch (Exception e) {
        // Expected
    }

    // Then
    LogAsserts.assertLogMessagePresentContaining(
        TestLogLevel.ERROR,
        JwtTokenLogMessages.ERROR.KEY_RETRIEVAL_FAILED.resolveIdentifierString());
}
----
