= Refactoring Plan: JWT Implementation Restructuring

== Refactoring Status

=== Completed Refactorings

==== Removal of requirementSource in ClaimName
The `requirementSource` attribute in the `ClaimName` enum has been moved to JavaDoc for each enum value, improving documentation and removing unnecessary fields. This change maintains the same information in the code while making it more maintainable.

==== JwtParser Interface Consolidation
The redundant `de.cuioss.jwt.token.domain.JwtParser` interface has been removed completely, and `de.cuioss.jwt.token.JwtParser` has been refactored to include factory methods for each token type that accept a `KeyInfo` parameter. This simplifies the API and reduces duplication.

==== Token Handling Refactoring
The token handling implementation has been refactored to use the JsonWebToken interface directly instead of going through the TokenContent hierarchy. This simplifies the API and makes it more flexible:

1. ParsedAccessToken, ParsedIdToken, and ParsedRefreshToken now directly wrap JsonWebToken objects
2. Token classes provide necessary accessors for token properties
3. JjwtAdapter implements JsonWebToken to provide a clean abstraction over JJWT's implementation
4. Factory methods in JwtParser now use the new implementation

==== Implementation of JsonWebToken Support
Added full JsonWebToken implementation capabilities:

1. JjwtAdapter now properly implements JsonWebToken interface with all required methods
2. Added utility methods to ensure consistent token handling
3. Updated TokenFactory usage to work with the new JsonWebToken-based approach
4. Implemented proper test support

=== In Progress

==== Test Coverage
Still need to fix failing tests for JwtAdapterTest. These tests are failing because they depend on the old implementation structure.

==== Documentation Updates
Need to update documentation to reflect the new API structure.
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

== Overview

This document outlines the plan for refactoring the JWT token handling implementation to improve code organization, reduce coupling to specific JWT libraries, and create a more maintainable architecture. The key objectives are:

1. Isolate all JJWT-specific code into a dedicated implementation package
2. Create a JJWT-agnostic representation of tokens and claims
3. Refactor token types to act as data transfer objects without dynamic computations
4. Design a more robust claim handling mechanism

== Current Structure

=== Current Package Structure

* `de.cuioss.jwt.token` - Core token classes and interfaces
* `de.cuioss.jwt.token.adapter` - Adapter classes for JWT implementation
* `de.cuioss.jwt.token.jwks` - JWKS handling
* `de.cuioss.jwt.token.security` - Security-related classes
* `de.cuioss.jwt.token.util` - Utility classes

=== Key Classes with Implementation-Specific Dependencies

* `de.cuioss.jwt.token.adapter.JwtAdapter` - Directly uses JJWT's `Jws<Claims>` type
* `de.cuioss.jwt.token.adapter.JsonWebToken` - Interface with methods reflecting JJWT's capabilities
* `de.cuioss.jwt.token.JwtParser` - Interface referencing JJWT types like `Jws<Claims>`
* `de.cuioss.jwt.token.ParsedAccessToken` - Contains dynamic computation logic for scopes and roles

== Refactoring Steps

=== Step 1: Create a Clean Domain Model

==== Create a new package structure

[source]
----
de.cuioss.jwt.token.domain
├── claim
│   ├── ClaimName.java           # Enum for standard claim names
│   ├── ClaimValueType.java      # Enum for claim value types
│   ├── ClaimValue.java          # Interface for claim values
│   ├── StringClaimValue.java    # String claim value impl
│   ├── StringListClaimValue.java # List of strings claim value impl
│   ├── StringSetClaimValue.java # Set of strings claim value impl  
│   ├── DateTimeClaimValue.java  # OffsetDateTime claim value impl
│   ├── BooleanClaimValue.java   # Boolean claim value impl
│   ├── NumberClaimValue.java    # Number claim value impl
│   └── Claim.java               # Combines ClaimName and ClaimValue
└── token
    ├── TokenContent.java        # Core interface for token content
    ├── BaseTokenContent.java    # Base impl of TokenContent
    ├── AccessTokenContent.java  # Access token specific content
    ├── IdTokenContent.java      # ID token specific content
    └── RefreshTokenContent.java # Refresh token specific content
----

==== Implement the ClaimValueType enum

See implementation: `src/main/java/de/cuioss/jwt/token/domain/claim/ClaimValueType.java`

This enum represents the supported claim value types in the system. The implementation includes:
- STRING: For simple string values like "iss", "sub", etc.
- STRING_LIST: For lists of strings
- STRING_SET: For sets of strings like roles, groups, and scopes
- DATETIME: For timestamp values represented as OffsetDateTime

==== Implement the base ClaimValue interface

See implementation: `src/main/java/de/cuioss/jwt/token/domain/claim/ClaimValue.java`

This interface defines the contract for all claim value types, with methods for:
- Getting the claim value type
- Getting the typed value
- Checking if the value is present
- Getting the original string representation

==== Implement the StringClaimValue class

See implementation: `src/main/java/de/cuioss/jwt/token/domain/claim/StringClaimValue.java`

This class implements ClaimValue for string values, maintaining both the typed value and the original string representation from the token.

==== Implement the StringSetClaimValue class

See implementation: `src/main/java/de/cuioss/jwt/token/domain/claim/StringSetClaimValue.java`

This class implements ClaimValue for sets of strings, used for roles, groups, and scopes. It maintains values in a SortedSet for consistent ordering while preserving the original string representation.

==== Implement the DateTimeClaimValue class

See implementation: `src/main/java/de/cuioss/jwt/token/domain/claim/DateTimeClaimValue.java`

This class implements ClaimValue for date-time values, used for claims like "exp", "iat", and "nbf". It preserves the original numeric string representation from the token while offering an OffsetDateTime interface.

==== Implement the ClaimName enum

See implementation: `src/main/java/de/cuioss/jwt/token/domain/claim/ClaimName.java`

This enum defines standard JWT claim names and their expected value types, based on RFC 7519, OpenID Connect, and OAuth 2.0 specifications. It provides:

- Standard claim name strings (replaces the old ClaimNames class)
- Expected value types for each claim
- Mandatory status of each claim per its specification
- Helper methods for validating claims
- Utility methods for getting mandatory claims by token type

==== Implement the Claim class

See implementation: `src/main/java/de/cuioss/jwt/token/domain/claim/Claim.java`

This class represents a claim in a JWT token, combining a ClaimName with a ClaimValue. It provides convenience methods for accessing the claim value and checking its presence.

==== Implement the token content interfaces

See implementation: `src/main/java/de/cuioss/jwt/token/domain/token/TokenContent.java`

This interface defines the core contract for JWT token content, providing:
- Access to claims and raw token data
- Validation of mandatory claims
- Convenience methods for common claim values (issuer, subject, expiration)
- Token validity checking
- Support for all token types

==== Implement BaseTokenContent

See implementation: `src/main/java/de/cuioss/jwt/token/domain/token/BaseTokenContent.java`

This abstract class provides the base implementation of TokenContent, with:
- Storage for claims and raw token
- Validation of mandatory claims during construction
- Common functionality shared by all token types
----

==== Implement AccessTokenContent

See implementation: `src/main/java/de/cuioss/jwt/token/domain/token/AccessTokenContent.java`

This class extends BaseTokenContent for OAuth 2.0 access tokens, providing:
- Extraction and storage of scopes and roles as SortedSets
- Email address management
- Access token-specific validation

==== Implement IdTokenContent

See implementation: `src/main/java/de/cuioss/jwt/token/domain/token/IdTokenContent.java`

This class extends BaseTokenContent for OpenID Connect ID tokens, providing:
- Access to ID token specific claims like name and email
- ID token-specific validation

==== Implement RefreshTokenContent

See implementation: `src/main/java/de/cuioss/jwt/token/domain/token/RefreshTokenContent.java`

This class extends BaseTokenContent for OAuth 2.0 refresh tokens in JWT format, with:
- Minimal validation requirements
- Support for JWT-formatted refresh tokens

=== Step 2: Create the Implementation Package for JJWT

==== Create the JJWT implementation package

The following package structure will isolate all JJWT-specific code:

```
de.cuioss.jwt.token.adapter.jjwt
├── JjwtAdapter.java           # Wraps JJWT's Jws<Claims>
├── JjwtTokenContentFactory.java # Creates TokenContent from JjwtAdapter
├── JjwtClaimExtractor.java    # Extracts claims from JJWT objects
└── JjwtParser.java            # JJWT-specific parser implementation
```

The implementations can be found in the corresponding files.

==== Implement the JjwtAdapter class

See implementation: `src/main/java/de/cuioss/jwt/token/adapter/jjwt/JjwtAdapter.java`

This class provides an adapter around JJWT's `Jws<Claims>` type, encapsulating JJWT's implementation details from the rest of the system.

==== Implement the JjwtClaimExtractor class

See implementation: `src/main/java/de/cuioss/jwt/token/adapter/jjwt/JjwtClaimExtractor.java`

This utility class extracts claims from JJWT's Claims object and converts them to the domain model claim types while preserving original string representations.

==== Implement the JjwtTokenContentFactory class

See implementation: `src/main/java/de/cuioss/jwt/token/adapter/jjwt/JjwtTokenContentFactory.java`

This factory creates TokenContent instances from JjwtAdapter objects:
- Creates AccessTokenContent, IdTokenContent, and RefreshTokenContent from JjwtAdapter
- Extracts claims from the JJWT Claims object
- Delegates to JjwtClaimExtractor for specific claim extraction logic
- Builds appropriate domain objects with the extracted claims

=== Step 3: Update Token Classes to Use the New Domain Model

==== Refactor ParsedAccessToken

See implementation: `src/main/java/de/cuioss/jwt/token/ParsedAccessToken.java`

The refactored ParsedAccessToken class acts as a Data Transfer Object without dynamic computation logic:
- Wraps an AccessTokenContent instance
- Delegates most methods to the underlying content object
- Provides convenient access to token properties like scopes, roles, issuer, subject
- Returns TokenType.ACCESS_TOKEN for token type identification
- Makes token handling more robust by separating storage from behavior

==== Refactor ParsedIdToken

See implementation: `src/main/java/de/cuioss/jwt/token/ParsedIdToken.java`

The refactored ParsedIdToken class serves as a Data Transfer Object for OpenID Connect ID tokens:
- Wraps an IdTokenContent instance
- Delegates methods to the underlying content object
- Provides access to ID token properties like issuer, subject, name, email
- Returns TokenType.ID_TOKEN for token type identification
- Implements Serializable for persistence

==== Refactor ParsedRefreshToken

See implementation: `src/main/java/de/cuioss/jwt/token/ParsedRefreshToken.java`

The ParsedRefreshToken class can handle both opaque and JWT-formatted refresh tokens:
- Stores the raw token string for all refresh tokens
- Optionally stores RefreshTokenContent for JWT-formatted tokens
- Provides methods to check token format (isJwtFormat())
- Returns the underlying token content when in JWT format
- Returns TokenType.REFRESH_TOKEN for token type identification
- Implements Serializable for persistence

=== Step 4: Update the Factory Classes

==== Update TokenFactory

See implementation: `src/main/java/de/cuioss/jwt/token/TokenFactory.java`

The TokenFactory interface defines the contract for creating and validating tokens:
- Creates access tokens from token strings with optional email association
- Creates ID tokens from token strings
- Creates refresh tokens from token strings
- Returns Optional results to handle invalid or unparseable tokens safely

==== Create a JJWT-specific implementation

See implementation: `src/main/java/de/cuioss/jwt/token/adapter/jjwt/JjwtTokenFactory.java`

The JjwtTokenFactory is a JJWT-specific implementation of the TokenFactory interface:
- Uses MultiIssuerJwtParser to find the appropriate parser for each token
- Creates JjwtAdapter instances to bridge between JJWT and domain model
- Uses JjwtTokenContentFactory to create domain model objects
- Handles empty or invalid tokens gracefully
- Detects JWT-formatted refresh tokens vs. opaque refresh tokens
- Provides detailed logging for token creation and parsing

=== Step 5: Update the JwtParser Interface

==== Create a TokenValidator class

See implementation: `src/main/java/de/cuioss/jwt/token/domain/token/TokenValidator.java`

The TokenValidator class provides additional validation for token instances based on RFC 7519:
- Validates tokens against expected issuer, audience, and client ID values
- Complements the built-in validation in TokenContent implementations 
- Provides context-specific validation based on external configuration
- Builds comprehensive validation error messages
- Supports flexible constructor options for different validation requirements

==== Create a new JwtParser interface in the domain package

See implementation: `src/main/java/de/cuioss/jwt/token/domain/JwtParser.java`

The domain JwtParser interface abstracts away implementation details:
- Defines methods for token parsing and validation
- Returns domain model TokenContent objects
- Provides issuer-related methods for multi-issuer support
- Separates interface from implementation
- Allows for different JWT library implementations

==== Create a bridge implementation in the JJWT implementation package

See implementation: `src/main/java/de/cuioss/jwt/token/adapter/jjwt/JjwtParserBridge.java`

The JjwtParserBridge implements the domain JwtParser interface:
- Acts as a bridge between the old JJWT-specific parser and the new domain model
- Delegates to the original JwtParser implementation 
- Converts JJWT objects to domain model objects using JjwtAdapter
- Preserves the issuer-related functionality
- Enables gradual migration to the new domain model

== Testing Strategy

=== Unit Tests for Domain Model

==== ClaimValue Tests

See implementation: `src/test/java/de/cuioss/jwt/token/domain/claim/StringClaimValueTest.java`

Tests for StringClaimValue verify:
- It returns the correct ClaimValueType
- It handles null values properly
- It provides the original string representation
- It preserves the original string when provided separately
- It implements object contract methods correctly

==== StringSetClaimValue Tests

See implementation: `src/test/java/de/cuioss/jwt/token/domain/claim/StringSetClaimValueTest.java`

Tests for StringSetClaimValue verify:
- It returns the correct ClaimValueType
- It handles null values by returning empty sets
- It provides a comma-separated string representation
- It preserves the original string when provided separately
- It maintains consistent ordering of values (always sorted)
----

==== DateTimeClaimValue Tests

See implementation: `src/test/java/de/cuioss/jwt/token/domain/claim/DateTimeClaimValueTest.java`

Tests for DateTimeClaimValue verify:
- It returns the correct ClaimValueType
- It handles null values properly
- It provides epoch seconds as string representation
- It preserves the original string when provided separately
- It can be created from epoch seconds
- It correctly converts between OffsetDateTime and epoch seconds
----

==== Claim Tests

See implementation: `src/test/java/de/cuioss/jwt/token/domain/claim/ClaimTest.java`

Tests for Claim verify:
- It provides type-safe access to claim values
- It implements Optional-like behavior for accessing values
- It handles null values properly
- It preserves the original string representation
- It implements object contract methods correctly
----

==== ClaimName Tests

See implementation: `src/test/java/de/cuioss/jwt/token/domain/claim/ClaimNameTest.java`

Tests for ClaimName verify:
- It correctly identifies mandatory claims
- It provides token-type specific mandatory claim sets
- It validates the presence of mandatory claims
- It can look up enum values by claim name string
- It includes correct requirement sources for each claim
- It provides appropriate value types for each claim
----

==== Token Content Tests

See implementations: 
- `src/test/java/de/cuioss/jwt/token/domain/token/AccessTokenContentTest.java`
- `src/test/java/de/cuioss/jwt/token/domain/token/IdTokenContentTest.java`
- `src/test/java/de/cuioss/jwt/token/domain/token/RefreshTokenContentTest.java`

Tests for token content classes verify:

AccessTokenContent tests:
- It extracts scopes from space-delimited scope claim
- It extracts roles from roles claim
- It validates mandatory claims for access tokens
- It detects expired tokens
- It validates tokens including scope presence

IdTokenContent tests:
- It correctly reports token type
- It provides access to ID token-specific claims like name and email
- It validates tokens with OpenID Connect requirements

RefreshTokenContent tests:
- It correctly reports token type
- It validates with minimal claim requirements
- It handles missing mandatory claims appropriately
----

=== Integration Tests

==== TokenValidator Tests

See implementation: `src/test/java/de/cuioss/jwt/token/domain/token/TokenValidatorTest.java`

Tests for TokenValidator verify:
- It validates tokens with matching issuer, audience, and client ID
- It detects issuer mismatches and provides clear error messages
- It detects audience mismatches when the token audience doesn't contain expected values
- It detects authorized party (azp) mismatches against expected client ID
- It detects missing authorized party claims when client ID validation is required
----

==== TokenFactory Tests

See implementation: `src/test/java/de/cuioss/jwt/token/adapter/jjwt/JjwtTokenFactoryTest.java`

Tests for JjwtTokenFactory verify:
- It creates ParsedAccessToken instances with correct properties and content
- It creates ParsedIdToken instances with correct metadata
- It creates opaque refresh tokens when the token string isn't JWT-formatted
- It detects and correctly handles JWT-formatted refresh tokens
- It uses TokenGenerators to generate test tokens with realistic content
----

== Migration Strategy

1. **Implement Core Domain Model**:
   * Create claim value types and ClaimName enum
   * Implement token content interfaces and classes
   * Add tests for domain model classes

2. **Implement JJWT Adapter Layer**:
   * Create JjwtAdapter and related classes
   * Implement the bridge between JJWT and domain model
   * Add tests for adapter layer

3. **Update Token Classes**:
   * Refactor ParsedAccessToken, ParsedIdToken, and ParsedRefreshToken
   * Make them use the new domain model
   * Add tests for refactored classes

4. **Update TokenFactory**:
   * Create a JJWT-specific implementation
   * Add tests for the factory

5. **Update JwtParser**:
   * Create the new interface in the domain package
   * Create a bridge implementation in the JJWT package
   * Add tests for the parser

6. **Update MultiIssuerJwtParser**:
   * Make it work with the new domain model

7. **Run Tests**:
   * Verify all components work correctly
   * Fix any issues

8. **Update Documentation**:
   * Update JavaDoc
   * Update technical documentation

== Implementation Order

1. Core domain model (claim and token packages)
2. JJWT adapter layer
3. Refactored token classes
4. Updated factory classes
5. New JwtParser interface
6. Updated MultiIssuerJwtParser
7. Tests and documentation

== Benefits

=== Better Separation of Concerns
* Clear separation between domain model and implementation details
* Token classes focus on their specific functionality
* DTO approach prevents dynamic computation in token classes

=== Reduced Coupling
* Core code doesn't depend on JJWT
* Easier to switch implementation libraries
* Domain model is implementation-agnostic

=== Improved Type Safety
* Strongly typed claim values
* Explicit handling of different claim types
* Consistent handling of null values

=== More Maintainable Code
* Clear package structure
* Consistent abstraction levels
* Better testability
* Lombok reduces boilerplate code
* Proper use of serialization
* Clear distinction between domain model and implementation