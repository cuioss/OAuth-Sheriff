= JWT Integration Performance Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Executive Summary

**Focus**: Quarkus JWT validation endpoint performance optimization

**Current Baseline** (August 5, 2025 - Performance Regression Detected):

- Health endpoint: 12,439 ops/s (improved from 11,311) âœ… 
- JWT validation: 8,770 ops/s (down from 10,943) ðŸ”´ **20% REGRESSION**
- CPU usage: 50% (down from 73%) - indicating underutilization

**Key Findings**:

- Health checks prove system can handle 12,439 ops/s
- JWT validation only achieving 8,770 ops/s (30% lower than health)
- CPU at 50% suggests computational bottleneck, not I/O
- JMH optimization: 24 threads optimal (was 30)

**Critical Issue**:

- JWT validation throughput regressed 20% since August 4
- Health endpoint improved, ruling out infrastructure issues
- Indicates JWT-specific performance degradation

== Performance Baseline Comparison

=== Performance Metrics - August 4 vs August 5

**Infrastructure**: Apple M4 (4 CPUs), OrbStack containerization, Quarkus native runtime, Java HttpClient

|===
| Endpoint Type | Aug 4 Throughput | Aug 5 Throughput | Change | Aug 5 P50 | Aug 5 P95 | Aug 5 P99 
| **Health Check** | 11,311 ops/s | 12,439 ops/s | +10% âœ… | 1,739Î¼s | 2,896Î¼s | 5,652Î¼s
| **JWT Validation** | 10,943 ops/s | 8,770 ops/s | -20% ðŸ”´ | 2,540Î¼s | 4,506Î¼s | 7,586Î¼s
| **Throughput Gap** | 3.2% | 41.8% | - | - | - | -
|===

=== August 4 Baseline (Previous High Performance)

|===
| Endpoint Type | Throughput | Sample Count | P50 Latency | P95 Latency | P99 Latency | Description
| **Health Check** | 11,311 ops/s | 116,096 | 782Î¼s | 1.54ms | 2.02ms | Simple health endpoint - EXCELLENT
| **JWT Validation** | 10,943 ops/s | 244,311 | 847Î¼s | 1.58ms | 2.15ms | JWT validation - EXCELLENT
| **Bearer Token** | - | 520,808 | 102Î¼s | 203Î¼s | 95.04ms | Internal JWT processing - P99 SPIKE
|===

=== System Resource Utilization

[source,text]
----
CPU Utilization:        73% (both cores actively utilized)
System Load Average:    1.8 (90% of 2-CPU capacity - healthy)
Heap Memory Used:       5.77 MB (very efficient!)
Non-heap Memory:        0 bytes (native image efficiency)
Container CPUs:         2 cores (OrbStack on Apple M4)
----

=== JWT Validation Performance Breakdown

[source,text]
----
JWT Validation P95 Latency:     1.58ms (Full request-response cycle) âœ…
â”œâ”€ HTTP/TLS Processing:         ~1.3ms (82%) - Network, TLS, HTTP parsing
â”œâ”€ Bearer Token Validation:     203Î¼s (13%) - JWT processing (P95)
â”‚   â”œâ”€ Token Parsing:           ~50Î¼s - JWT structure validation
â”‚   â”œâ”€ Signature Check:         ~120Î¼s - Cryptographic validation
â”‚   â””â”€ Claims Validation:       ~33Î¼s - Issuer, expiry checks
â”œâ”€ Quarkus Framework:           ~70Î¼s (4%) - CDI, routing, filters
â””â”€ Response Generation:         ~7Î¼s (1%) - JSON serialization

Internal Metrics (520,808 validation samples):
- Bearer Token P50: 102Î¼s (excellent!)
- Bearer Token P95: 203Î¼s (outstanding!)
- Bearer Token P99: 95.04ms (SPIKE - needs investigation)
- Success rate: 40.2% (117,041 success / 290,938 total)
- Error rate: 59.8% (173,897 KEY_NOT_FOUND errors)
----

== Performance Analysis

=== 1. Excellent Baseline Performance âœ… **ACHIEVED TARGETS**

**Achievement**: System exceeding performance targets

**Key Metrics**:

- Throughput: 10,943-11,311 ops/s (exceeded 10K target!)
- P95 Latency: All endpoints <2ms (well below 5ms target)
- P50 Latency: All endpoints <850Î¼s (sub-millisecond)
- Memory usage: Only 5.77MB heap (very efficient)

**Success Factors**:

- Native image compilation providing excellent performance
- Efficient JWT validation implementation
- Low memory footprint
- Good CPU utilization without oversaturation

=== 2. P99 Bearer Token Spike ðŸŸ¡ **INVESTIGATION NEEDED**

**Problem**: 468x jump from P95 (203Î¼s) to P99 (95.04ms) in bearer token processing

**Impact**:

- <1% of internal validations experience 95ms delays
- Overall endpoint P99 still good (2-2.7ms)
- Indicates periodic issue, not continuous problem

**Likely Causes**:

- Periodic key rotation or cache miss
- JIT compilation or deoptimization events
- Virtual thread scheduling anomaly
- Possible monitoring overhead

=== 3. High Error Rate Pattern ðŸŸ¡ **EXPECTED BEHAVIOR**

**Observation**: 59.8% error rate (KEY_NOT_FOUND)

**Analysis**:

- This appears to be the benchmark testing invalid tokens
- 173,897 KEY_NOT_FOUND errors are expected for security testing
- Not a performance issue, but benchmark design
- Success rate of 40.2% is reasonable for mixed testing

== Optimization Strategy

=== ðŸ”´ Priority 1: Fix JWT Validation Performance Regression (20% throughput loss)

**Goal**: Restore JWT validation throughput from 8,770 ops/s back to 10,943+ ops/s

**Root Cause Analysis Tasks**:

1. **Compare Code Changes**:
   ```bash
   # Check what changed between August 4 and August 5
   git log --since="2025-08-04" --until="2025-08-05" --oneline -- cui-jwt-quarkus-parent/
   git diff db66e8b..HEAD -- cui-jwt-quarkus-parent/cui-jwt-quarkus/src/main/java/de/cuioss/jwt/
   ```

2. **Profile JWT Validation Hot Paths**:
   ```bash
   # Run JFR profiling to identify CPU bottlenecks
   mvn clean verify -Pbenchmark-jfr -pl benchmarking/benchmark-integration-quarkus
   jfr print --events CPULoad,ExecutionSample --stack-depth 20 target/benchmark-jfr-results/jfr-recordings/*.jfr
   ```

3. **Analyze Cryptographic Operations**:
   - Check if signature verification algorithm changed
   - Verify JWKS key loading performance
   - Profile RSA/ECDSA operations
   - Check for synchronization bottlenecks

4. **Thread Utilization Analysis**:
   ```java
   // Add thread-level metrics to understand CPU underutilization
   @Counted(name = "jwt_validation_thread_active")
   @Timed(name = "jwt_validation_thread_time")
   public void validateToken() {
       // Track per-thread utilization
   }
   ```

5. **Comparative Benchmark**:
   ```bash
   # Run side-by-side comparison with August 4 build
   git checkout db66e8b  # Last known good commit
   mvn clean package -pl cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
   # Save the native binary
   
   git checkout feature/integration-perfomance-optimization
   # Run benchmarks against both binaries
   ```

=== ðŸŸ¡ Priority 2: Optimize JWT Processing for Raw Performance

**Goal**: Close the 41.8% throughput gap between health checks and JWT validation

**Actionable Tasks**:

1. **Parallel Token Validation**:
   ```java
   // Investigate if token parts can be validated in parallel
   CompletableFuture<Boolean> signatureCheck = CompletableFuture.supplyAsync(() -> verifySignature());
   CompletableFuture<Boolean> claimsCheck = CompletableFuture.supplyAsync(() -> validateClaims());
   CompletableFuture<Boolean> expiryCheck = CompletableFuture.supplyAsync(() -> checkExpiry());
   ```

2. **Optimize Cryptographic Libraries**:
   - Benchmark BouncyCastle vs native Java crypto
   - Consider hardware acceleration (AES-NI, SHA extensions)
   - Profile key loading and caching

3. **Remove Synchronization Bottlenecks**:
   ```bash
   # Find synchronized blocks and locks
   grep -r "synchronized\|Lock\|Semaphore" cui-jwt-quarkus-parent/cui-jwt-quarkus/src/
   ```

4. **Native Image Optimizations**:
   ```xml
   <!-- Try aggressive native optimizations -->
   <quarkus.native.additional-build-args>
     -O3,
     -march=native,
     --enable-all-security-services,
     --initialize-at-build-time
   </quarkus.native.additional-build-args>
   ```

=== ðŸŸ¢ Priority 3: Investigate P99 Bearer Token Spike

=== Priority 2: CPU Optimization âœ… **MOSTLY IMPLEMENTED**

**Goal**: Reduce CPU usage from 73% to ~60% for better headroom

**Already Implemented**:

1. **Connection Pooling**: âœ… HttpClientFactory uses cached clients with 50-thread pool
2. **Cache System**: âœ… Access token cache with configurable size and eviction
3. **Native Image Optimization**: âœ… Using -O2 optimization flag

**Remaining Options**:

- Consider increasing native optimization to -O3 (currently using -O2)
- Fine-tune thread pool size based on load testing
- Monitor and adjust cache eviction intervals

=== Priority 3: Monitoring and Observability âœ… **PARTIALLY IMPLEMENTED**

**Goal**: Better understand performance characteristics

**Already Implemented**:

1. **Metrics Collection**: âœ… MetricsPostProcessor with P50/P95/P99 percentiles
2. **Cache Metrics**: âœ… JWKS cache size monitoring
3. **JFR Profiling**: âœ… Integrated via benchmark-jfr profile

**Remaining Actions**:

1. **Additional Percentiles**: Add P99.9 and P99.99 tracking
2. **Cache Hit/Miss Ratios**: Implement detailed cache effectiveness metrics
3. **Real-time Dashboard**: Set up Grafana or similar for live monitoring
4. **Alerting Rules**: Configure Prometheus alerts for thresholds


== Success Metrics

=== Performance Achievements vs Targets

|===
| Metric | Actual | Original Target | Status
| **P95 Latency (JWT)** | 1.58ms | <5ms | âœ… EXCEEDED (3x better)
| **P95 Latency (Health)** | 1.54ms | <5ms | âœ… EXCEEDED (3x better)
| **P99 Latency (Endpoints)** | 2.0-2.2ms | <20ms | âœ… EXCEEDED (9-10x better)
| **Throughput (Health)** | 11,311 ops/s | >10,000 ops/s | âœ… ACHIEVED
| **Throughput (JWT)** | 10,943 ops/s | >10,000 ops/s | âœ… ACHIEVED
| **CPU Usage** | 73% | <40% | ðŸŸ¡ Higher but acceptable
| **Memory Usage** | 5.77MB | <70% of heap | âœ… EXCELLENT
| **Bearer Token P99** | 95ms | <1ms | ðŸ”´ Spike issue
|===

=== Validation Protocol

[source,bash]
----
# Run comprehensive benchmarks
./mvnw clean verify -pl benchmarking/benchmark-integration-quarkus -Pbenchmark

# Monitor resources during benchmark
docker stats --no-stream

# Analyze GC behavior (with JFR profile)
mvn clean verify -Pbenchmark-jfr
jfr print --events GarbageCollection target/benchmark-jfr-results/jfr-recordings/*.jfr
----


== Key Achievements and Remaining Work

=== Achieved Performance Goals âœ…

1. **Latency Excellence**:
   - All endpoints P95 < 2ms (target was <5ms)
   - All endpoints P99 < 3ms (target was <20ms)
   - P50 latencies all sub-millisecond or near

2. **Throughput Success**:
   - Health: 11,311 ops/s (exceeded 10K target)
   - JWT: 10,943 ops/s (exceeded 10K target)

3. **Resource Efficiency**:
   - Memory usage only 5.77MB (excellent)
   - Native image working efficiently
   - No heap pressure observed

=== Remaining Optimization Opportunities ðŸŽ¯

1. **P99 Bearer Token Spike**:
   - Investigate 95ms spike (468x jump from P95)
   - Likely cache miss or initialization issue
   - Should be reducible to <1ms

2. **CPU Headroom**:
   - Current 73% leaves limited headroom
   - Target 60% for better burst capacity
   - Connection pooling could help

3. **Observability**:
   - Add more granular metrics
   - Track cache effectiveness
   - Monitor outlier patterns

== Monitoring and Alerting

=== Key Metrics to Track

1. **Latency Metrics**:
   - P50, P95, P99 per endpoint
   - Bearer token validation duration
   - HTTP processing time

2. **Resource Metrics**:
   - CPU utilization and load average
   - Memory usage and GC frequency
   - Thread pool saturation

3. **Application Metrics**:
   - Request throughput
   - Error rates by category
   - Cache hit ratios

=== Updated Alert Thresholds

Given the excellent baseline performance, tighter thresholds are appropriate:

- P95 latency > 3ms for >1 minute (currently ~1.5-1.8ms)
- P99 latency > 5ms for >30 seconds (currently ~2-2.7ms)
- Bearer token P99 > 10ms for >10 seconds (currently spikes to 95ms)
- CPU usage > 80% for >5 minutes (currently 73%)
- Memory usage > 20MB for >2 minutes (currently 5.77MB)
- Error rate deviation > 10% from baseline

== Immediate Action Items (August 5, 2025)

=== 1. Investigate Performance Regression ðŸ”´ **URGENT**

```bash
# Step 1: Check recent code changes
git log --since="2025-08-04" --until="2025-08-05" --oneline -- cui-jwt-quarkus-parent/

# Step 2: Run JFR profiling
mvn clean verify -Pbenchmark-jfr -pl benchmarking/benchmark-integration-quarkus

# Step 3: Compare CPU profiles
jfr print --events ExecutionSample --stack-depth 50 target/benchmark-jfr-results/jfr-recordings/*.jfr | head -200

# Step 4: Check for lock contention
jfr print --events JavaMonitorWait,JavaMonitorEnter target/benchmark-jfr-results/jfr-recordings/*.jfr
```

=== 2. Quick Performance Wins ðŸŸ¡

1. **Verify Native Compilation Flags**:
   ```bash
   # Check current optimization level
   grep "native.additional-build-args" cui-jwt-quarkus-parent/pom.xml
   ```

2. **Profile Token Validation**:
   ```java
   // Add timing to each validation step
   long start = System.nanoTime();
   // ... validation step ...
   long duration = System.nanoTime() - start;
   metrics.record("jwt.validation.step.X", duration);
   ```

3. **Check Thread Pool Configuration**:
   ```bash
   # Verify HTTP client thread pool settings
   grep -r "executor\|thread\|pool" benchmarking/benchmark-integration-quarkus/src/
   ```

=== 3. Benchmark Comparison Script ðŸŸ¢

Create a script to compare performance between commits:

```bash
#!/bin/bash
# compare-performance.sh

# Checkout and build August 4 version
git checkout db66e8b
mvn clean package -DskipTests -pl cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
cp target/*-runner /tmp/jwt-aug4-runner

# Checkout and build current version  
git checkout feature/integration-perfomance-optimization
mvn clean package -DskipTests -pl cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
cp target/*-runner /tmp/jwt-current-runner

# Run benchmarks on both
echo "Testing August 4 build..."
# ... benchmark commands ...

echo "Testing current build..."
# ... benchmark commands ...
```

== Conclusion

The JWT validation endpoint showed **performance regression on August 5, 2025**:

**Current Status**:

- ðŸ”´ JWT Throughput: 8,770 ops/s (down from 10,943) - **20% regression**
- âœ… Health Throughput: 12,439 ops/s (up from 11,311) - **10% improvement**
- ðŸ”´ Performance Gap: 41.8% between health and JWT (was 3.2%)
- ðŸŸ¡ CPU Usage: 50% (down from 73%) - **underutilization**
- âœ… JMH Optimization: 24 threads optimal (was 30)

**Key Findings**:

1. **Infrastructure is NOT the bottleneck** - health checks improved
2. **JWT-specific performance issue** - 30% slower than health endpoint
3. **CPU underutilization** - only 50% usage indicates compute bottleneck
4. **Raw cryptographic performance** needs optimization

**Critical Actions**:

- ðŸ”´ **URGENT**: Investigate code changes between Aug 4-5
- ðŸ”´ **URGENT**: Profile JWT validation hot paths with JFR
- ðŸŸ¡ **HIGH**: Optimize cryptographic operations
- ðŸŸ¡ **HIGH**: Remove synchronization bottlenecks
- ðŸŸ¢ **MEDIUM**: Explore parallel validation strategies

The system has the capacity for 12,439+ ops/s (proven by health checks) but JWT validation is currently limiting throughput to 8,770 ops/s. Focus must be on optimizing the JWT validation computation path.

== Related Documentation

- **Microbenchmark Performance**: Core library optimization (separate track)
- **Benchmark Infrastructure**: JMH configuration and execution
- **Container Configuration**: Docker and OrbStack optimization
- **Native Image Tuning**: GraalVM and Quarkus native settings