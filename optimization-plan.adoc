= JWT Integration Test Latency Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Critical Build Information

**Build Commands:** 
```bash
# Run benchmarks with distroless containers (production testing)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-testing

# Run benchmarks with JFR profiling containers (performance analysis)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-jfr
```

**Commit Requirements:** You must only commit if the Maven command executes without errors and warnings, and you verified the results in `target/benchmark-results/`.

== Executive Summary

=== Current Performance Baseline (July 22, 2025)

**Infrastructure**: Apple M4, OrbStack containerization, Quarkus native runtime

|===
| Algorithm | P95 Latency | Throughput | Processing Overhead | Token Length | Provider | Status
| **RS256** | **143.0ms** | **1,533 req/sec** | **138.9ms** | 977 chars | BouncyCastle | ✅ CURRENT
| RS256 (Default JDK) | 173.0ms | 1,413 req/sec | 168.0ms | 977 chars | SUN | ⚪ BASELINE
| **Health Check** | **3.5ms** | **38,683 req/sec** | **0ms (baseline)** | N/A | N/A | ✅ BASELINE
|===

**Current Focus**: Reduce RS256 JWT validation latency from 143ms to <20ms through RSA-specific optimizations.

**Optimization Achievement**:
- BouncyCastle: 17% improvement (173ms → 143ms)
- **Note**: -march=native optimization removed due to Docker portability concerns

=== Quick Performance Summary

**RS256 Performance**: 143.0ms P95 latency (194.8ms with new metrics), 1,533 req/sec throughput (BouncyCastle)
**Target**: <20ms P95 latency (10ms achievable based on 5ms microbenchmark)
**Remaining Gap**: 123ms (86% improvement still needed)
**Bottleneck**: RSA signature verification (`BigInteger.modPow()` ~97% of time)

**New Metrics Insights**:
- Average validation time: 16.573ms (complete_validation)
- Individual steps sum: 6.395ms (token_parsing + header_validation + claims_validation + signature_validation)
- **Unaccounted overhead: 10.178ms (61.4%)** - likely framework/HTTP processing
- High variance: P95 (194.8ms) and P99 (267.9ms) are 11.8x and 16.2x higher than average

=== Infrastructure Optimization Status ✅ **COMPLETED**

**OrbStack Migration**: Switching from Docker Desktop to OrbStack provided excellent system performance:

- Health Check: 5.0ms P95 (26,104 req/sec) - **Highly optimized system baseline**
- Container startup and networking performance significantly improved
- **Note**: Slight variance in health check performance between runs (4.1-5.0ms)

== Performance Analysis Summary

=== JFR Analysis Results ✅ **COMPLETED**

**Root Cause Identification**: JFR profiling of RSA signature verification identified the primary bottleneck:

- **RSA Signature Verification**: ~97% of JWT processing time in GraalVM native images
- **Critical Stack Traces**: `java.math.BigInteger.modPow()` operations dominating CPU time
- **Evidence**: `sun.security.rsa.RSACore.crypt()` and `de.cuioss.jwt.validation.pipeline.TokenSignatureValidator.verifySignature()` as primary CPU consumers

**Performance Breakdown (RS256 with BouncyCastle)**:

- System Infrastructure: 4.1ms (networking, HTTP, Docker)
- RSA Signature Verification: ~134ms (BouncyCastle RSA operations)
- JWT Parsing/Validation: ~5ms (library logic - matches microbenchmark)
- **Total**: 143.0ms P95
- **Gap to Target**: 134ms RSA overhead must be reduced to <16ms
- **BouncyCastle Benefit**: 29ms RSA overhead reduction vs default JDK

=== Critical Findings

1. **System Baseline**: 3.5ms P95 (health check) - Infrastructure is highly optimized
2. **JWT Processing**: 137.9ms additional overhead for RS256 with BouncyCastle + -march=native
3. **BouncyCastle Impact**: 17% improvement over default JDK (173.0ms → 143.0ms)
4. **RSA Bottleneck**: `BigInteger.modPow()` operations consume ~94% of JWT validation time
5. **Algorithm Migration Success**: ES256 → RS256 improved performance by 71.7% (504.9ms → 143.0ms)
6. **Provider Optimization Success**: SUN → BouncyCastle improved performance by 17.3%

== Next Steps - Actionable Tasks

=== Priority 1: RSA Performance Optimization 🚀 **NEXT FOCUS**

**Goal**: Reduce RSA signature verification overhead from 134ms to target <16ms

**Current Status**: RS256 with BouncyCastle at 143.0ms P95 (1,533 req/sec)
**Microbenchmark Reference**: JWT library alone achieves 5ms - proving <10ms is possible
**BouncyCastle Benefit**: 17% improvement (29ms reduction) over default JDK provider

**Next Optimization Paths**:

1. **GraalVM Native Image Tuning** ⭐ **IMMEDIATE ACTION**:
+
[source,bash]
----
# Add to native image build
-march=native                    # ARM64 CPU-specific optimizations
-O2                             # Standard optimization level (default)
--pgo-instrument                # Generate PGO data
--pgo=profile.iprof            # Use PGO data for RSA hotpaths
----

2. **Java 24 + GraalNN Upgrade** (Optional - Oracle GraalVM Only):
+
[source,bash]
----
# Requires Oracle GraalVM for JDK 24
-O3                             # Enables GraalNN ML-powered profiler
----
+
   - **Expected**: 7.9% improvement (143ms → ~132ms)
   - **Cost**: Migration to non-LTS Java 24
   - **Risk**: Limited benefit for RSA computational bottleneck
   - **Docker**: Use `amazoncorretto:24` base image

3. **BouncyCastle Provider** ✅ **COMPLETED**:
   - Integrated with 17% improvement (173ms → 143ms)
   - 29ms RSA overhead reduction vs default JDK

4. **Production Monitoring Implementation** ✅ **COMPLETED**:
   - Library-agnostic metrics collection implemented via TokenValidatorMonitor
   - Pipeline step measurement for each JWT validation phase (token_parsing, header_validation, claims_validation, signature_validation, complete_validation)
   - Quarkus module integration with Micrometer translation layer (CuiJwtMetricsProducer)
   - Real-world performance insights now available through Prometheus metrics

**Target Performance**: <20ms P95 (123ms improvement needed from current 143ms BouncyCastle baseline)

=== Priority 2: Metrics Analysis & Optimization 📊 **NEW FINDINGS**

**Goal**: Address critical gaps identified in benchmark monitoring analysis

**Key Findings from Benchmark Analysis**:

1. **Missing Performance Time** 🔴 **CRITICAL**:
   - Complete validation: 16.573ms average
   - Sum of individual steps: 6.395ms
   - **Unaccounted time: 10.178ms (61.4% of total)**
   - This missing time is likely framework overhead, HTTP processing, or unmeasured operations

2. **Inconsistent Metric Collection** ⚠️ **WARNING**:
   - Header validation: Only 14 of 29 requests (48.3%) recorded
   - Suggests conditional validation logic or metric recording issues

3. **High Latency Variance** ⚠️ **WARNING**:
   - Average: 16.573ms
   - P95: 194.8ms (11.8x average)
   - P99: 267.9ms (16.2x average)
   - Indicates GC pauses, resource contention, or periodic operations

**Required Actions**:

1. **Add Missing Metrics in JWT Validation Library** ✅ **COMPLETED**:
   - Added TOKEN_FORMAT_CHECK measurement for empty/blank validation
   - Added ISSUER_EXTRACTION measurement for issuer claim extraction
   - Added ISSUER_CONFIG_RESOLUTION measurement for config lookup
   - Added TOKEN_BUILDING measurement for token object creation
   - Added token type tracking (access/id/refresh) in metrics

2. **Fix Header Validation Metrics** ✅ **RESOLVED**:
   - Root cause identified: Refresh tokens skip the validation pipeline
   - No fix needed - this is expected behavior for refresh tokens
   - Consider adding separate refresh token metrics

3. **Add HTTP-Level Metrics in Quarkus Module** ✅ **COMPLETED**:
   - Implemented HttpMetricsMonitor for HTTP-level performance tracking
   - Measures REQUEST_PROCESSING (total HTTP request time)
   - Measures HEADER_EXTRACTION (Authorization header access)
   - Measures TOKEN_EXTRACTION (Bearer token extraction)
   - Measures AUTHORIZATION_CHECK (scopes/roles/groups validation)
   - Tracks request outcomes: SUCCESS, MISSING_TOKEN, INVALID_TOKEN, INSUFFICIENT_PERMISSIONS
   - Integrated with JwtMetricsCollector for Prometheus export

4. **Profile High Percentile Latencies**:
   - Add JFR events for outlier detection
   - Monitor GC activity during benchmarks
   - Track thread pool and connection pool metrics

5. **Benchmark Infrastructure Updates**:
   - Add warmup period to eliminate JIT compilation effects
   - Extend measurement duration for stable percentiles
   - Monitor CPU and memory usage during tests


=== Priority 3: Benchmark Infrastructure Enhancement 🔧

**Goal**: Improve measurement accuracy and coverage

**Tasks**:

1. **Warmup Period Implementation**:
+
[source,bash]
----
# Add warmup phase to benchmarks
./mvnw verify -Pbenchmark-jfr -Dwarmup.duration=60s -Dmeasurement.duration=120s
----

2. **Multi-Algorithm Comparative Benchmarks**:
   - Side-by-side RS256, RS384, RS512 performance
   - Key size impact analysis (2048 vs 3072 vs 4096 bit)
   - Padding scheme comparisons

3. **Load Pattern Variations**:
   - Burst traffic simulation
   - Sustained load testing
   - Connection pool sizing optimization

== Implementation Status

=== Completed Optimizations ✅

1. **Benchmark Infrastructure**: Maven-based execution with JFR profiling
2. **Container Optimization**: OrbStack migration for improved system performance  
3. **Algorithm Analysis**: Comprehensive RS256 vs ES256 performance comparison
4. **JFR Profiling**: Root cause identification (BigInteger.modPow bottleneck)
5. **ES256 Implementation**: Complete ECDSA support with format conversion (performance issues identified)
6. **Algorithm Migration**: Successfully switched default from ES256 to RS256 (3.1x improvement)
7. **Research Documentation**: Proven 8x ES256/RS256 gap is algorithmic, not implementation-based
8. **BouncyCastle JCA Provider**: Integrated with 17% performance improvement (29ms reduction)

9. **Production Metrics Integration**: Complete TokenValidatorMonitor implementation
   - **Library-level**: TokenValidatorMonitor interface with DefaultTokenValidatorMonitor implementation
   - **Pipeline metrics**: Automatic timing for token_parsing, header_validation, claims_validation, signature_validation, complete_validation
   - **Quarkus integration**: CuiJwtMetricsProducer translates to Micrometer metrics
   - **Prometheus export**: cui_jwt_validation_duration_seconds histogram with step labels
   - **Benchmark integration**: Metrics collected during performance tests for analysis

10. **Integration Test Build Optimization**: Reduced incremental build time from >2 minutes to 22 seconds
    - Disabled automatic native compilation in Maven lifecycle
    - Added conditional build script (build-native-if-needed.sh)
    - Native executable built only when missing (first run or after clean)

11. **Enhanced JWT Validation Metrics**: Added comprehensive measurement coverage
    - **Library-level**: Added 4 new MeasurementType entries for missing operations
    - **Access token focus**: Metrics only recorded for access token validation (pre-1.0 compliance)
    - **Complete coverage**: Now measures all validation steps (format check, issuer extraction, config resolution, token building)
    - **Performance-optimized**: ID and refresh token validation skip metrics recording for zero overhead

12. **HTTP-Level Metrics Implementation**: Captures framework and HTTP processing overhead
    - **HttpMetricsMonitor**: New monitor for HTTP-specific measurements
    - **Request lifecycle tracking**: REQUEST_PROCESSING, HEADER_EXTRACTION, TOKEN_EXTRACTION, AUTHORIZATION_CHECK
    - **Status tracking**: Monitors request outcomes (SUCCESS, MISSING_TOKEN, INVALID_TOKEN, INSUFFICIENT_PERMISSIONS)
    - **Micrometer integration**: Exposes metrics via cui.jwt.http.request.duration and cui.jwt.http.request.count
    - **Addresses 61.4% gap**: Helps identify the 10.178ms unaccounted overhead in benchmark results

=== In Progress

==== 1. Profile-Guided Optimization (PGO)
**Status:** ❌ NOT AVAILABLE - Mandrel doesn't support PGO

**Research Finding**: PGO is only available in Oracle GraalVM Enterprise Edition. Since Quarkus uses Mandrel (based on GraalVM Community Edition) by default, PGO cannot be used. Would require switching to Oracle GraalVM Enterprise with associated licensing costs.

**Alternative**: Focus on other optimizations available in Mandrel:
- CPU-specific optimizations (-march=native) ✅ **COMPLETED**
- Memory tuning via quarkus.native.native-image-xmx
- Algorithm and key size optimizations

=== Dismissed Items (Do Not Revisit)

==== 1. ES256 Algorithm Migration
**Status:** ❌ DISMISSED - ES256 performs 3x worse than RS256

**Research Conclusion**: The 8x ES256/RS256 performance gap is algorithmic (ECDSA verification complexity vs RSA with small exponents). Java ECDSA implementations are additionally 3x slower than native. Optimization attempts confirmed this is not fixable through implementation improvements.

==== 2. Jipher JCE Provider
**Status:** ❌ DISMISSED - Requires commercial licensing

**Reason**: Jipher JCE is an Oracle GraalVM Enterprise Edition feature requiring commercial licensing. See xref:cui-jwt-quarkus-parent/doc/performance/graalvm-enterprise-optimization-options.adoc[GraalVM Enterprise Optimization Options] for enterprise-specific solutions.

==== 3. Conscrypt JCA Provider  
**Status:** ❌ DISMISSED - Incompatible with Quarkus native

**Research**: Quarkus Issue #4248 documents `ClassNotFoundException: org.conscrypt.BufferAllocator` when using Conscrypt with native images. Requires complex reflection configuration that may not be maintainable.

==== 4. Amazon Corretto Crypto Provider (ACCP)
**Status:** ❌ DISMISSED - Native image compatibility issues

**Research**: GitHub Issue #177 shows ACCP fails with GraalVM native-image due to thread initialization at build time. No official Quarkus native support documented as of 2025.

==== 5. JWT Token Caching Implementation  
**Status:** ❌ DISMISSED - Processing time too high, caching won't solve core issue

==== 6. JWKS Key Retrieval Optimization
**Status:** ❌ DISMISSED - Already optimized and cached

==== 7. TLS/HTTPS Optimization
**Status:** ❌ DISMISSED - No TLS bottleneck identified (3.5ms health check baseline)

==== 8. CPU-Specific Optimization (-march=native)
**Status:** ❌ DISMISSED - Compromises Docker container portability

**Research Finding**: -march=native optimizes for build-time CPU architecture only, not runtime architecture. Since containers may run on different hardware than build environment (ARM64 build vs x86_64 production), this creates deployment compatibility issues. The 1.1% performance gain (1.6ms) doesn't justify the portability risk.

==== 9. Hardware-Specific Acceleration (Intel AES-NI, ARM Crypto Extensions)
**Status:** ❌ DISMISSED - Not suitable for general Docker containers

**Reason**: Hardware-specific optimizations compromise portability. The library must work across different architectures and deployment environments. Always aim for general Docker container compatibility rather than system-specific acceleration.

==== 10. RSA Key Size Optimization
**Status:** ❌ DISMISSED - Not suitable for general library design

**Reason**: The library must support industry-standard key sizes (2048-bit minimum for security). While smaller keys would improve performance (~2x faster with 1024-bit), they are cryptographically insecure. Larger keys (3072-bit) would degrade performance (~2x slower). The library should remain agnostic to key size choices made by token issuers.