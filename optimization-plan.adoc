= JWT Integration Test Latency Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Critical Build Information

**Build Commands:** 
```bash
# Run benchmarks with distroless containers (production testing)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-testing

# Run benchmarks with JFR profiling containers (performance analysis)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-jfr
```

**Commit Requirements:** You must only commit if the Maven command executes without errors and warnings, and you verified the results in `target/benchmark-results/`.

== Executive Summary

=== Current Performance Baseline (July 22, 2025)

**Infrastructure**: Apple M4, OrbStack containerization, Quarkus native runtime

| Algorithm | P95 Latency | Throughput | Processing Overhead | Token Length |
|-----------|------------|------------|-------------------|--------------|
| **RS256** | **170.7ms** | **1,426 req/sec** | **166.6ms** | 977 chars |
| **ES256** | **504.9ms** | **450 req/sec** | **500.8ms** | 721 chars |
| **Health Check** | **4.1ms** | **33,553 req/sec** | **0ms (baseline)** | N/A |

**Key Finding**: **ES256 is 3x slower than RS256** in GraalVM native images, contradicting cryptographic performance expectations.

=== Algorithm Performance Analysis

**RS256 (Current Best Performer)**:
- P95 Latency: 170.7ms
- Throughput: 1,426 req/sec
- Processing Overhead: 166.6ms
- Status: ✅ **RECOMMENDED**

**ES256 (Poor Performer)**:
- P95 Latency: 504.9ms  
- Throughput: 450 req/sec
- Processing Overhead: 500.8ms
- Status: ❌ **AVOID** - 3x slower than RS256

**Root Cause (ES256 Performance Issues)**:
- ECDSA signature format conversion overhead (IEEE P1363 ↔ ASN.1/DER)
- GraalVM native image ECDSA optimization deficiencies
- Possible cui-jwt library ECDSA implementation inefficiencies

=== Infrastructure Optimization Status ✅ **COMPLETED**

**OrbStack Migration**: Switching from Docker Desktop to OrbStack provided excellent system performance:
- Health Check: 4.1ms P95 (33,553 req/sec) - **Highly optimized system baseline**
- Container startup and networking performance significantly improved

== Performance Analysis Summary

=== JFR Analysis Results ✅ **COMPLETED**

**Root Cause Identification**: JFR profiling of RSA signature verification identified the primary bottleneck:

- **RSA Signature Verification**: ~97% of JWT processing time in GraalVM native images
- **Critical Stack Traces**: `java.math.BigInteger.modPow()` operations dominating CPU time
- **Evidence**: `sun.security.rsa.RSACore.crypt()` and `de.cuioss.jwt.validation.pipeline.TokenSignatureValidator.verifySignature()` as primary CPU consumers

**Performance Breakdown (RS256)**:
- System Infrastructure: 4.1ms (networking, HTTP, Docker)
- RSA Signature Verification: ~162ms (BigInteger.modPow operations)
- JWT Parsing/Validation: ~4ms (library logic)
- **Total**: 170.7ms P95

=== Critical Findings

1. **System Baseline**: 4.1ms P95 (health check) - Infrastructure is highly optimized
2. **JWT Processing**: 166.6ms additional overhead for RS256
3. **Algorithm Impact**: RS256 significantly outperforms ES256 in GraalVM native images
4. **RSA Bottleneck**: `BigInteger.modPow()` operations consume 97% of JWT validation time

== Next Steps - Actionable Tasks

=== Priority 1: RSA Performance Optimization

**Goal**: Reduce RSA signature verification overhead from 166.6ms to target <50ms

**Current Status**: RS256 established as baseline at 170.7ms P95

**Optimization Paths**:

1. **GraalVM Native Image Tuning**:
   - Investigate `-march=native` for ARM64 optimization
   - Profile-guided optimization (PGO) for RSA operations
   - Native image build parameter optimization

2. **Alternative JCA Providers**:
   - Research BouncyCastle JCE performance in native images
   - Evaluate Jipher JCE (if available) for OpenSSL integration
   - Compare JCA provider RSA performance characteristics

3. **RSA Implementation Analysis**:
   - Deep dive into `BigInteger.modPow()` performance bottlenecks
   - Investigate RSA key size optimization (2048 vs 4096 bit)
   - Analyze RSA-PSS vs PKCS#1 padding performance

**Target Performance**: 50ms P95 (>3x improvement from current 170.7ms)

=== Priority 1: ES256 Implementation Performance Fix ❌ **CRITICAL**

**Goal**: Fix ES256 implementation that performs 3x worse than RS256

**Status**: ✅ **ROOT CAUSE IDENTIFIED** - Inefficient signature format conversion

**JFR Analysis Results** (July 22, 2025):
- **Current ES256 Performance**: 592.2ms P95 (vs 5.2ms health check baseline)
- **JWT Processing Overhead**: 587.0ms (compared to ~170ms for RS256)
- **Performance Regression**: ES256 is consistently 3x slower than expected

**Microbenchmark Analysis Results**:

**✅ SIGNATURE FORMAT CONVERSION PERFORMANCE**:
- **EcdsaSignatureFormatConverter**: **2.8 μs per conversion** (NOT the bottleneck)
- **ECParameterSpec initialization**: **3.1 μs per initialization** (NOT the bottleneck)
- **Both operations are performing optimally** and cannot explain 587ms overhead

**❌ ROOT CAUSE STILL UNKNOWN**:
- **Current ES256 Performance**: 592.2ms P95 (vs 5.2ms health check baseline)
- **JWT Processing Overhead**: 587.0ms (compared to ~170ms for RS256)
- **Microbenchmark Results**: Format conversion + parameter init = ~6 μs total

**Performance Mystery**:
- Expected bottlenecks (format conversion, key parsing) are fast
- Actual 587ms overhead remains unexplained
- **Something else in the ES256 validation pipeline is causing the delay**

**Investigation Status**: ❌ **BOTTLENECK IDENTIFICATION FAILED**

**Next Investigation Required**:
1. **Full JWT validation pipeline profiling** - Compare ES256 vs RS256 end-to-end
2. **Network/JWKS fetching analysis** - Check if ES256 triggers different key loading
3. **Token parsing differences** - Examine JWT header/payload processing for ES256
4. **Validation path analysis** - Identify ES256-specific code paths causing delays
5. **Container/GraalVM investigation** - Check if native image has ES256-specific issues

**Current Hypothesis**:
The 587ms delay may be coming from:
- **Different JWKS key loading patterns** for ECDSA vs RSA
- **ES256-specific validation logic** not visible in isolated microbenchmarks  
- **Network timeouts or retries** specific to ES256 key fetching
- **GraalVM native image optimization issues** with ECDSA libraries

**Target Performance**: ES256 should achieve <50ms processing overhead (12x improvement needed)

=== Priority 3: Advanced Optimization (If Needed)

**Goal**: Additional optimizations if RSA tuning doesn't achieve target performance

- **Token Caching Strategy**: Application-level validated token caching
- **Memory Allocation**: Optimize BigInteger operations memory patterns  
- **Connection Optimization**: JWKS loading and HTTP client tuning

== Implementation Status

=== Completed Optimizations ✅

1. **Benchmark Infrastructure**: Maven-based execution with JFR profiling
2. **Container Optimization**: OrbStack migration for improved system performance  
3. **Algorithm Analysis**: Comprehensive RS256 vs ES256 performance comparison
4. **JFR Profiling**: Root cause identification (BigInteger.modPow bottleneck)
5. **ES256 Implementation**: Complete ECDSA support with format conversion (performance issues identified)

=== Dismissed Items (Do Not Revisit)

==== 1. ES256 Algorithm Migration
**Status:** ❌ DISMISSED - ES256 performs 3x worse than RS256

==== 2. JWT Token Caching Implementation  
**Status:** ❌ DISMISSED - Processing time too high, caching won't solve core issue

==== 3. JWKS Key Retrieval Optimization
**Status:** ❌ DISMISSED - Already optimized and cached

==== 4. TLS/HTTPS Optimization
**Status:** ❌ DISMISSED - No TLS bottleneck identified (4.1ms health check baseline)