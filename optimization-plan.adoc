= JWT Integration Test Latency Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Critical Build Information

**Build Commands:** 
```bash
# Run benchmarks with distroless containers (production testing)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-testing

# Run benchmarks with JFR profiling containers (performance analysis)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-jfr
```

**Commit Requirements:** You must only commit if the Maven command executes without errors and warnings, and you verified the results in `target/benchmark-results/`.

== Executive Summary

=== Current Performance Baseline (July 22, 2025)

**Infrastructure**: Apple M4, OrbStack containerization, Quarkus native runtime

| Algorithm | P95 Latency | Throughput | Processing Overhead | Token Length |
|-----------|------------|------------|-------------------|--------------|
| **RS256** | **170.7ms** | **1,426 req/sec** | **166.6ms** | 977 chars |
| **ES256** | **504.9ms** | **450 req/sec** | **500.8ms** | 721 chars |
| **Health Check** | **4.1ms** | **33,553 req/sec** | **0ms (baseline)** | N/A |

**Key Finding**: **ES256 is 3x slower than RS256** in GraalVM native images, contradicting cryptographic performance expectations.

=== Algorithm Performance Analysis

**RS256 (Current Best Performer)**:
- P95 Latency: 170.7ms
- Throughput: 1,426 req/sec
- Processing Overhead: 166.6ms
- Status: ✅ **RECOMMENDED**

**ES256 (Poor Performer)**:
- P95 Latency: 504.9ms  
- Throughput: 450 req/sec
- Processing Overhead: 500.8ms
- Status: ❌ **AVOID** - 3x slower than RS256

**Root Cause (ES256 Performance Issues)**:
- ECDSA signature format conversion overhead (IEEE P1363 ↔ ASN.1/DER)
- GraalVM native image ECDSA optimization deficiencies
- Possible cui-jwt library ECDSA implementation inefficiencies

=== Infrastructure Optimization Status ✅ **COMPLETED**

**OrbStack Migration**: Switching from Docker Desktop to OrbStack provided excellent system performance:
- Health Check: 4.1ms P95 (33,553 req/sec) - **Highly optimized system baseline**
- Container startup and networking performance significantly improved

== Performance Analysis Summary

=== JFR Analysis Results ✅ **COMPLETED**

**Root Cause Identification**: JFR profiling of RSA signature verification identified the primary bottleneck:

- **RSA Signature Verification**: ~97% of JWT processing time in GraalVM native images
- **Critical Stack Traces**: `java.math.BigInteger.modPow()` operations dominating CPU time
- **Evidence**: `sun.security.rsa.RSACore.crypt()` and `de.cuioss.jwt.validation.pipeline.TokenSignatureValidator.verifySignature()` as primary CPU consumers

**Performance Breakdown (RS256)**:
- System Infrastructure: 4.1ms (networking, HTTP, Docker)
- RSA Signature Verification: ~162ms (BigInteger.modPow operations)
- JWT Parsing/Validation: ~4ms (library logic)
- **Total**: 170.7ms P95

=== Critical Findings

1. **System Baseline**: 4.1ms P95 (health check) - Infrastructure is highly optimized
2. **JWT Processing**: 166.6ms additional overhead for RS256
3. **Algorithm Impact**: RS256 significantly outperforms ES256 in GraalVM native images
4. **RSA Bottleneck**: `BigInteger.modPow()` operations consume 97% of JWT validation time

== Next Steps - Actionable Tasks

=== Priority 1: RSA Performance Optimization

**Goal**: Reduce RSA signature verification overhead from 166.6ms to target <50ms

**Current Status**: RS256 established as baseline at 170.7ms P95

**Optimization Paths**:

1. **GraalVM Native Image Tuning**:
   - Investigate `-march=native` for ARM64 optimization
   - Profile-guided optimization (PGO) for RSA operations
   - Native image build parameter optimization

2. **Alternative JCA Providers**:
   - Research BouncyCastle JCE performance in native images
   - Evaluate Jipher JCE (if available) for OpenSSL integration
   - Compare JCA provider RSA performance characteristics

3. **RSA Implementation Analysis**:
   - Deep dive into `BigInteger.modPow()` performance bottlenecks
   - Investigate RSA key size optimization (2048 vs 4096 bit)
   - Analyze RSA-PSS vs PKCS#1 padding performance

**Target Performance**: 50ms P95 (>3x improvement from current 170.7ms)

=== Priority 2: ES256 Performance Investigation ⚠️ **RESEARCH ONLY**

**Goal**: Understand why ES256 performs 3x worse than RS256

**Status**: ❌ **AVOID ES256** - Performance significantly worse than RS256

**Investigation Areas**:
- ECDSA signature format conversion efficiency
- GraalVM native image ECDSA optimization gaps  
- Alternative ECDSA implementation approaches

**Note**: ES256 optimization is **LOW PRIORITY** given poor performance baseline

=== Priority 3: Advanced Optimization (If Needed)

**Goal**: Additional optimizations if RSA tuning doesn't achieve target performance

- **Token Caching Strategy**: Application-level validated token caching
- **Memory Allocation**: Optimize BigInteger operations memory patterns  
- **Connection Optimization**: JWKS loading and HTTP client tuning

== Implementation Status

=== Completed Optimizations ✅

1. **Benchmark Infrastructure**: Maven-based execution with JFR profiling
2. **Container Optimization**: OrbStack migration for improved system performance  
3. **Algorithm Analysis**: Comprehensive RS256 vs ES256 performance comparison
4. **JFR Profiling**: Root cause identification (BigInteger.modPow bottleneck)
5. **ES256 Implementation**: Complete ECDSA support with format conversion (performance issues identified)

=== Dismissed Items (Do Not Revisit)

==== 1. ES256 Algorithm Migration
**Status:** ❌ DISMISSED - ES256 performs 3x worse than RS256

==== 2. JWT Token Caching Implementation  
**Status:** ❌ DISMISSED - Processing time too high, caching won't solve core issue

==== 3. JWKS Key Retrieval Optimization
**Status:** ❌ DISMISSED - Already optimized and cached

==== 4. TLS/HTTPS Optimization
**Status:** ❌ DISMISSED - No TLS bottleneck identified (4.1ms health check baseline)