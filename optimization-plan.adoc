= JWT Integration Performance Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Executive Summary

**Focus**: Quarkus JWT validation endpoint performance optimization

**Current Baseline** (August 4, 2025):

- Health endpoint: 3.44ms P95 âœ…
- Echo endpoint: 8.18ms P95 (baseline behavior, no optimization needed)
- JWT validation: 3.76ms P95 âœ…
- Internal JWT processing: 362Î¼s P95 (excellent)

**Primary Concerns**:

- Resource constraints: 69% CPU, 95% memory usage
- P99 latency spikes: 155ms (GC/scheduling issues)

== Performance Baseline (August 4, 2025)

=== Current Performance Metrics

**Infrastructure**: Apple M4 (2 CPUs), OrbStack containerization, Quarkus native runtime, Java HttpClient

|===
| Endpoint Type | JMH Throughput | Sample Count | P50 Latency | P95 Latency | P99 Latency | Description
| **Health Check** | 4,892 ops/s | 61,310 | 1.31ms | 3.44ms | 7.07ms | Simple health endpoint
| **Echo Endpoint** | 2,623 ops/s | 33,032 | 2.19ms | 8.18ms | 14.36ms | Echo with JWT validation (baseline)
| **JWT Invalid** | 3,094 ops/s | 125,946 | 1.48ms | 3.76ms | 8.65ms | JWT validation (failure)
| **JWT Valid** | 3,741 ops/s | - | ~1.5ms | ~3.8ms | ~8.7ms | Full JWT validation (success)
| **Missing Auth** | 7,773 ops/s | - | <1ms | <2ms | <5ms | No JWT processing
|===

=== System Resource Utilization

```
CPU Utilization:        69% (both cores heavily utilized)
System Load Average:    2.4 (120% of 2-CPU capacity)
Heap Memory Used:       9.96 MB (95% of 10.49 MB committed)
Non-heap Memory:        0 bytes (native image efficiency)
Container CPUs:         2 cores (OrbStack on Apple M4)
```

=== JWT Validation Performance Breakdown

```
JWT Validation P95 Latency:     3.76ms (Full request-response cycle)
â”œâ”€ HTTP/TLS Processing:         ~3.0ms (80%) - Network, TLS, HTTP parsing
â”œâ”€ Bearer Token Validation:     362Î¼s (9.6%) - JWT processing (P95)
â”‚   â”œâ”€ Token Parsing:           ~100Î¼s - JWT structure validation
â”‚   â”œâ”€ Signature Check:         ~200Î¼s - Cryptographic validation
â”‚   â””â”€ Claims Validation:       ~62Î¼s - Issuer, expiry checks
â”œâ”€ Quarkus Framework:           ~360Î¼s (9.6%) - CDI, routing, filters
â””â”€ Response Generation:         ~38Î¼s (1%) - JSON serialization

Internal Metrics (290,017 validation samples):
- Bearer Token P50: 181Î¼s
- Bearer Token P95: 362Î¼s
- Bearer Token P99: 155.14ms (outliers)
- Success rate: 25.5% (74,078 success / 290,017 total)
```

== Current Performance Bottlenecks

=== 1. Resource Constraints ðŸ”´ **CRITICAL**

**Problem**: System running at capacity limits

**Impact**:
- CPU at 69% with 2.4 load average (oversubscribed)
- Memory at 95% utilization (9.96MB of 10.49MB)
- May be limiting throughput potential
- Contributing to P99 latency spikes

**Root Causes**:
- Insufficient heap allocation for workload
- Only 2 CPU cores for concurrent request handling
- Memory pressure triggering frequent GC
- Container resource limits too restrictive

=== 2. P99 Latency Spikes ðŸ”´ **HIGH PRIORITY**

**Problem**: 428x jump from P95 (362Î¼s) to P99 (155.14ms)

**Impact**:
- 1% of requests experience >150ms delays
- Unpredictable user experience
- Affects SLA compliance

**Root Causes**:
- GC pauses due to 95% memory usage
- Thread scheduling delays under high CPU load
- Virtual thread carrier pool saturation
- Potential memory allocation hotspots

=== 3. Throughput Optimization Potential âœ… **GOOD BASELINE**

**Current Performance**: 2,623-7,773 ops/s across endpoints

**Analysis**:
- Health endpoint: 4,892 ops/s (highest for complex endpoint)
- JWT validation: 3,094-3,741 ops/s (consistent)
- Echo endpoint: 2,623 ops/s (lowest due to higher latency)
- Missing Auth: 7,773 ops/s (fastest, minimal processing)

**Optimization Potential**:
- With resource constraints resolved, could reach 10,000+ ops/s
- Current throughput limited by CPU saturation (69%)
- Memory pressure may cause throttling

== Optimization Strategy

=== Priority 1: Resource Optimization

**Goal**: Increase available resources to eliminate constraints

**Actions**:

1. **Memory Configuration**:
   ```properties
   # Increase heap for native image
   quarkus.native.additional-build-args=\
     -H:InitialHeapSize=32m \
     -H:MaxHeapSize=64m \
     -H:+PrintGCSummary
   ```

2. **Container Resources**:
   ```yaml
   # Docker compose adjustment
   resources:
     limits:
       cpus: '4'
       memory: 128M
     reservations:
       cpus: '2'
       memory: 64M
   ```

3. **Expected Impact**:
   - Reduce CPU usage to <40%
   - Reduce memory usage to <70%
   - Eliminate GC pressure
   - Improve P99 latency

=== Priority 2: P99 Outlier Mitigation

**Goal**: Reduce P99 from 155ms to <20ms

**Investigation Steps**:

1. **GC Analysis**:
   ```bash
   # Add JFR profiling for GC events
   -XX:StartFlightRecording=filename=jwt-gc.jfr,settings=profile
   -XX:+UnlockDiagnosticVMOptions
   -XX:+DebugNonSafepoints
   ```

2. **Memory Profiling**:
   - Identify allocation hotspots
   - Check for large object allocations
   - Monitor heap fragmentation

3. **Mitigation Strategies**:
   - Tune GC for low latency (Serial GC for native)
   - Implement object pooling for frequently allocated objects
   - Add circuit breaker for overload protection

=== Priority 3: Throughput Enhancement

**Goal**: Increase throughput from current 2,600-7,700 ops/s to >10,000 ops/s

**Actions**:

1. **Remove Resource Bottlenecks**:
   - Increase CPU cores to reduce saturation
   - Expand memory to eliminate GC pressure
   - Monitor throughput improvements

2. **Connection Pool Optimization**:
   ```java
   // Increase concurrent connections
   HttpClient client = HttpClient.newBuilder()
       .executor(Executors.newFixedThreadPool(16))
       .version(HttpClient.Version.HTTP_2)
       .build();
   ```

3. **Validation**:
   - Measure throughput after resource increases
   - Profile CPU usage distribution
   - Identify any remaining bottlenecks

=== Priority 4: HTTP/TLS Optimization

**Goal**: Reduce network overhead where possible

**Optimization Options**:

1. **HTTP/2 Multiplexing**:
   ```java
   HttpClient client = HttpClient.newBuilder()
       .version(HttpClient.Version.HTTP_2)
       .connectTimeout(Duration.ofSeconds(2))
       .build();
   ```

2. **Connection Pooling**:
   - Increase pool size for concurrent requests
   - Optimize keep-alive settings
   - Pre-warm connections on startup

3. **TLS Optimization**:
   - Enable TLS session resumption
   - Use TLS 1.3 for reduced handshake
   - Consider Unix Domain Sockets for local communication

== Success Metrics

=== Performance Targets

|===
| Metric | Current | Target | Priority
| **P95 Latency (JWT)** | 3.76ms | <5ms | âœ… Achieved
| **P95 Latency (Health)** | 3.44ms | <5ms | âœ… Achieved
| **P99 Latency (All)** | 155ms | <20ms | High
| **CPU Usage** | 69% | <40% | Critical
| **Memory Usage** | 95% | <70% | Critical
| **Throughput** | 2,623-7,773 ops/s | >10,000 ops/s | Medium
|===

=== Validation Protocol

```bash
# Run comprehensive benchmarks
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-jmh -Pbenchmark

# Monitor resources during benchmark
docker stats --no-stream

# Analyze GC behavior
jfr print --events GarbageCollection jwt-benchmark.jfr
```

== Implementation Timeline

=== Week 1: Resource Optimization
- Day 1-2: Increase container resources
- Day 3-4: Implement memory configuration changes
- Day 5: Validate impact on P99 latency

=== Week 2: Performance Tuning
- Day 1-2: GC tuning and profiling
- Day 3-4: JMH configuration optimization
- Day 5: HTTP/TLS improvements

=== Week 3: Validation and Monitoring
- Day 1-2: Comprehensive benchmark suite
- Day 3-4: Performance dashboard setup
- Day 5: Documentation and knowledge transfer

== Expected Outcomes

With the proposed optimizations:

1. **Resource Utilization**:
   - CPU usage reduced to <40%
   - Memory usage reduced to <70%
   - Stable performance under load

2. **Latency Improvements**:
   - P99 reduced from 155ms to <20ms
   - Consistent sub-5ms P95 for all endpoints
   - Predictable performance characteristics

3. **Throughput Gains**:
   - Increase from current 2,600-7,700 ops/s to >10,000 ops/s
   - Better scalability with available resources
   - Improved concurrent request handling

4. **Operational Benefits**:
   - Reduced GC pressure and pauses
   - Better resource headroom for traffic spikes
   - Improved monitoring and observability

== Monitoring and Alerting

=== Key Metrics to Track

1. **Latency Metrics**:
   - P50, P95, P99 per endpoint
   - Bearer token validation duration
   - HTTP processing time

2. **Resource Metrics**:
   - CPU utilization and load average
   - Memory usage and GC frequency
   - Thread pool saturation

3. **Application Metrics**:
   - Request throughput
   - Error rates by category
   - Cache hit ratios

=== Alert Thresholds

- P95 latency > 5ms for >1 minute
- P99 latency > 20ms for >30 seconds
- CPU usage > 60% for >5 minutes
- Memory usage > 80% for >2 minutes
- Error rate > 5% for >1 minute

== Related Documentation

- **Microbenchmark Performance**: Core library optimization (separate track)
- **Benchmark Infrastructure**: JMH configuration and execution
- **Container Configuration**: Docker and OrbStack optimization
- **Native Image Tuning**: GraalVM and Quarkus native settings