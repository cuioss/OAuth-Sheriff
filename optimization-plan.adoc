= JWT Integration Test Latency Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Critical Build Information

**Build Commands:** 
```bash
# Run benchmarks with distroless containers (production testing)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-testing

# Run benchmarks with JFR profiling containers (performance analysis)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-jfr
```

**Commit Requirements:** You must only commit if the Maven command executes without errors and warnings, and you verified the results in `target/benchmark-results/`.

== Executive Summary

=== Current Performance Baseline (July 22, 2025)

**Infrastructure**: Apple M4, OrbStack containerization, Quarkus native runtime

|===
| Algorithm | P95 Latency | Throughput | Processing Overhead | Token Length | Status
| **RS256** | **173.0ms** | **1,413 req/sec** | **168.0ms** | 977 chars | ✅ CURRENT
| **Health Check** | **5.0ms** | **26,104 req/sec** | **0ms (baseline)** | N/A | ✅ BASELINE
|===

**Current Focus**: Reduce RS256 JWT validation latency from 173ms to <20ms through RSA-specific optimizations.

=== Quick Performance Summary

**RS256 Performance**: 173.0ms P95 latency, 1,413 req/sec throughput
**Target**: <20ms P95 latency (10ms achievable based on 5ms microbenchmark)
**Bottleneck**: RSA signature verification (`BigInteger.modPow()` ~97% of time)

=== Infrastructure Optimization Status ✅ **COMPLETED**

**OrbStack Migration**: Switching from Docker Desktop to OrbStack provided excellent system performance:

- Health Check: 5.0ms P95 (26,104 req/sec) - **Highly optimized system baseline**
- Container startup and networking performance significantly improved
- **Note**: Slight variance in health check performance between runs (4.1-5.0ms)

== Performance Analysis Summary

=== JFR Analysis Results ✅ **COMPLETED**

**Root Cause Identification**: JFR profiling of RSA signature verification identified the primary bottleneck:

- **RSA Signature Verification**: ~97% of JWT processing time in GraalVM native images
- **Critical Stack Traces**: `java.math.BigInteger.modPow()` operations dominating CPU time
- **Evidence**: `sun.security.rsa.RSACore.crypt()` and `de.cuioss.jwt.validation.pipeline.TokenSignatureValidator.verifySignature()` as primary CPU consumers

**Performance Breakdown (RS256)**:

- System Infrastructure: 5.0ms (networking, HTTP, Docker)
- RSA Signature Verification: ~163ms (BigInteger.modPow operations)
- JWT Parsing/Validation: ~5ms (library logic - matches microbenchmark)
- **Total**: 173.0ms P95
- **Gap to Target**: 163ms RSA overhead must be reduced to <15ms

=== Critical Findings

1. **System Baseline**: 5.0ms P95 (health check) - Infrastructure is highly optimized
2. **JWT Processing**: 168.0ms additional overhead for RS256 (down from 500.8ms with ES256)
3. **Algorithm Impact**: RS256 performs 3.1x better than ES256 - **confirmed algorithmic difference**
4. **RSA Bottleneck**: `BigInteger.modPow()` operations consume ~97% of JWT validation time
5. **Migration Success**: Switching to RS256 reduced latency by 65.7% (504.9ms → 173.0ms)

== Next Steps - Actionable Tasks

=== Priority 1: RSA Performance Optimization 🚀 **NEXT FOCUS**

**Goal**: Reduce RSA signature verification overhead from 168ms to target <20ms

**Current Status**: RS256 baseline established at 173.0ms P95 (1,413 req/sec)
**Microbenchmark Reference**: JWT library alone achieves 5ms - proving <10ms is possible

**Next Optimization Paths**:

1. **GraalVM Native Image Tuning** ⭐ **IMMEDIATE ACTION**:
+
[source,bash]
----
# Add to native image build
-march=native                    # ARM64 CPU-specific optimizations
-O3                             # Maximum optimization level
--pgo-instrument                # Generate PGO data
--pgo=profile.iprof            # Use PGO data for RSA hotpaths
----

2. **BouncyCastle Provider Testing** (Quarkus Native Compatible):
+
[source,properties]
----
# application.properties
quarkus.security.security-providers=BC
----
+
[source,xml]
----
<dependency>
    <groupId>org.bouncycastle</groupId>
    <artifactId>bcprov-jdk18on</artifactId>
</dependency>
----
+
   - ✅ **Confirmed compatible** with Quarkus native via `quarkus-security` extension
   - Expected modest performance improvement over default JDK provider

3. **BigInteger.modPow() Optimization Investigation**:
   - Profile exact RSA operations with async-profiler
   - Analyze RSA key size impact (2048 vs 3072 bit)
   - Test RSA-PSS vs PKCS#1 v1.5 padding performance

**Target Performance**: <20ms P95 (10ms achievable based on 5ms microbenchmark)

=== Priority 2: Production Monitoring Setup 📊 **REQUIRED**

**Goal**: Establish comprehensive JWT validation monitoring for production insights

**Implementation Tasks**:

1. **Micrometer Metrics Integration**:
+
[source,java]
----
@Timed(value = "jwt.validation.time", histogram = true)
@Counted(value = "jwt.validation.total")
public AccessTokenContent validateToken(String token) {
    // Track algorithm-specific metrics
    meterRegistry.counter("jwt.validation.algorithm", "type", algorithm).increment();
}
----

2. **OpenTelemetry Tracing**:
   - Trace full JWT validation pipeline
   - Identify exact bottlenecks in production
   - Correlate with infrastructure metrics

3. **Custom JFR Events** (for better native image profiling):
+
[source,java]
----
@Name("jwt.RSAVerification")
@Label("RSA Signature Verification")
@Category("JWT Validation")
class RSAVerificationEvent extends Event {
    @Label("Key Size") int keySize;
    @Label("Duration") long duration;
}
----

**Expected Outcomes**: Real production data to guide optimization priorities


=== Priority 3: Benchmark Infrastructure Enhancement 🔧

**Goal**: Improve measurement accuracy and coverage

**Tasks**:

1. **Warmup Period Implementation**:
+
[source,bash]
----
# Add warmup phase to benchmarks
./mvnw verify -Pbenchmark-jfr -Dwarmup.duration=60s -Dmeasurement.duration=120s
----

2. **Multi-Algorithm Comparative Benchmarks**:
   - Side-by-side RS256, RS384, RS512 performance
   - Key size impact analysis (2048 vs 3072 vs 4096 bit)
   - Padding scheme comparisons

3. **Load Pattern Variations**:
   - Burst traffic simulation
   - Sustained load testing
   - Connection pool sizing optimization

== Implementation Status

=== Completed Optimizations ✅

1. **Benchmark Infrastructure**: Maven-based execution with JFR profiling
2. **Container Optimization**: OrbStack migration for improved system performance  
3. **Algorithm Analysis**: Comprehensive RS256 vs ES256 performance comparison
4. **JFR Profiling**: Root cause identification (BigInteger.modPow bottleneck)
5. **ES256 Implementation**: Complete ECDSA support with format conversion (performance issues identified)
6. **Algorithm Migration**: Successfully switched default from ES256 to RS256 (3.1x improvement)
7. **Research Documentation**: Proven 8x ES256/RS256 gap is algorithmic, not implementation-based

=== Dismissed Items (Do Not Revisit)

==== 1. ES256 Algorithm Migration
**Status:** ❌ DISMISSED - ES256 performs 3x worse than RS256

**Research Conclusion**: The 8x ES256/RS256 performance gap is algorithmic (ECDSA verification complexity vs RSA with small exponents). Java ECDSA implementations are additionally 3x slower than native. Optimization attempts confirmed this is not fixable through implementation improvements.

==== 2. Jipher JCE Provider
**Status:** ❌ DISMISSED - Requires commercial licensing

**Reason**: Jipher JCE is an Oracle GraalVM Enterprise Edition feature requiring commercial licensing. See xref:cui-jwt-quarkus-parent/doc/performance/graalvm-enterprise-optimization-options.adoc[GraalVM Enterprise Optimization Options] for enterprise-specific solutions.

==== 3. Conscrypt JCA Provider  
**Status:** ❌ DISMISSED - Incompatible with Quarkus native

**Research**: Quarkus Issue #4248 documents `ClassNotFoundException: org.conscrypt.BufferAllocator` when using Conscrypt with native images. Requires complex reflection configuration that may not be maintainable.

==== 4. Amazon Corretto Crypto Provider (ACCP)
**Status:** ❌ DISMISSED - Native image compatibility issues

**Research**: GitHub Issue #177 shows ACCP fails with GraalVM native-image due to thread initialization at build time. No official Quarkus native support documented as of 2025.

==== 5. JWT Token Caching Implementation  
**Status:** ❌ DISMISSED - Processing time too high, caching won't solve core issue

==== 6. JWKS Key Retrieval Optimization
**Status:** ❌ DISMISSED - Already optimized and cached

==== 7. TLS/HTTPS Optimization
**Status:** ❌ DISMISSED - No TLS bottleneck identified (5.0ms health check baseline)