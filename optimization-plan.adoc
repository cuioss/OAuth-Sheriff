= JWT Integration Performance Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Executive Summary

**Focus**: Quarkus JWT validation endpoint performance optimization

**Current Baseline** (August 4, 2025):
- Health endpoint: 3.44ms P95 ‚úÖ
- Echo endpoint: 8.18ms P95 (baseline behavior, no optimization needed)
- JWT validation: 3.76ms P95 ‚úÖ
- Internal JWT processing: 362Œºs P95 (excellent)

**Primary Concerns**:
- Resource constraints: 69% CPU, 95% memory usage
- P99 latency spikes: 155ms (GC/scheduling issues)
- Low benchmark throughput: 2-7 ops/s (configuration issue)

== Performance Baseline (August 4, 2025)

=== Current Performance Metrics

**Infrastructure**: Apple M4 (2 CPUs), OrbStack containerization, Quarkus native runtime, Java HttpClient

|===
| Endpoint Type | JMH Throughput | Sample Count | P50 Latency | P95 Latency | P99 Latency | Description
| **Health Check** | 4.89 ops/s | 61,310 | 1.31ms | 3.44ms | 7.07ms | Simple health endpoint
| **Echo Endpoint** | 2.62 ops/s | 33,032 | 2.19ms | 8.18ms | 14.36ms | Echo with JWT validation (baseline)
| **JWT Invalid** | 3.09 ops/s | 125,946 | 1.48ms | 3.76ms | 8.65ms | JWT validation (failure)
| **JWT Valid** | 3.74 ops/s | - | ~1.5ms | ~3.8ms | ~8.7ms | Full JWT validation (success)
| **Missing Auth** | 7.77 ops/s | - | <1ms | <2ms | <5ms | No JWT processing
|===

=== System Resource Utilization

```
CPU Utilization:        69% (both cores heavily utilized)
System Load Average:    2.4 (120% of 2-CPU capacity)
Heap Memory Used:       9.96 MB (95% of 10.49 MB committed)
Non-heap Memory:        0 bytes (native image efficiency)
Container CPUs:         2 cores (OrbStack on Apple M4)
```

=== JWT Validation Performance Breakdown

```
JWT Validation P95 Latency:     3.76ms (Full request-response cycle)
‚îú‚îÄ HTTP/TLS Processing:         ~3.0ms (80%) - Network, TLS, HTTP parsing
‚îú‚îÄ Bearer Token Validation:     362Œºs (9.6%) - JWT processing (P95)
‚îÇ   ‚îú‚îÄ Token Parsing:           ~100Œºs - JWT structure validation
‚îÇ   ‚îú‚îÄ Signature Check:         ~200Œºs - Cryptographic validation
‚îÇ   ‚îî‚îÄ Claims Validation:       ~62Œºs - Issuer, expiry checks
‚îú‚îÄ Quarkus Framework:           ~360Œºs (9.6%) - CDI, routing, filters
‚îî‚îÄ Response Generation:         ~38Œºs (1%) - JSON serialization

Internal Metrics (290,017 validation samples):
- Bearer Token P50: 181Œºs
- Bearer Token P95: 362Œºs
- Bearer Token P99: 155.14ms (outliers)
- Success rate: 25.5% (74,078 success / 290,017 total)
```

== Current Performance Bottlenecks

=== 1. Resource Constraints üî¥ **CRITICAL**

**Problem**: System running at capacity limits

**Impact**:
- CPU at 69% with 2.4 load average (oversubscribed)
- Memory at 95% utilization (9.96MB of 10.49MB)
- Limiting throughput to 2-7 ops/s
- Contributing to P99 latency spikes

**Root Causes**:
- Insufficient heap allocation for workload
- Only 2 CPU cores for concurrent request handling
- Memory pressure triggering frequent GC
- Container resource limits too restrictive

=== 2. P99 Latency Spikes üî¥ **HIGH PRIORITY**

**Problem**: 428x jump from P95 (362Œºs) to P99 (155.14ms)

**Impact**:
- 1% of requests experience >150ms delays
- Unpredictable user experience
- Affects SLA compliance

**Root Causes**:
- GC pauses due to 95% memory usage
- Thread scheduling delays under high CPU load
- Virtual thread carrier pool saturation
- Potential memory allocation hotspots

=== 3. Low JMH Throughput ‚ö†Ô∏è **INVESTIGATION NEEDED**

**Problem**: JMH reporting only 2-7 ops/s despite good latencies

**Potential Issues**:
- JMH configuration problem (warmup, iterations, threads)
- Resource constraints limiting benchmark execution
- Measurement methodology issue
- Container throttling during benchmarks

== Optimization Strategy

=== Priority 1: Resource Optimization

**Goal**: Increase available resources to eliminate constraints

**Actions**:

1. **Memory Configuration**:
   ```properties
   # Increase heap for native image
   quarkus.native.additional-build-args=\
     -H:InitialHeapSize=32m \
     -H:MaxHeapSize=64m \
     -H:+PrintGCSummary
   ```

2. **Container Resources**:
   ```yaml
   # Docker compose adjustment
   resources:
     limits:
       cpus: '4'
       memory: 128M
     reservations:
       cpus: '2'
       memory: 64M
   ```

3. **Expected Impact**:
   - Reduce CPU usage to <40%
   - Reduce memory usage to <70%
   - Eliminate GC pressure
   - Improve P99 latency

=== Priority 2: P99 Outlier Mitigation

**Goal**: Reduce P99 from 155ms to <20ms

**Investigation Steps**:

1. **GC Analysis**:
   ```bash
   # Add JFR profiling for GC events
   -XX:StartFlightRecording=filename=jwt-gc.jfr,settings=profile
   -XX:+UnlockDiagnosticVMOptions
   -XX:+DebugNonSafepoints
   ```

2. **Memory Profiling**:
   - Identify allocation hotspots
   - Check for large object allocations
   - Monitor heap fragmentation

3. **Mitigation Strategies**:
   - Tune GC for low latency (Serial GC for native)
   - Implement object pooling for frequently allocated objects
   - Add circuit breaker for overload protection

=== Priority 3: Benchmark Configuration Optimization

**Goal**: Achieve realistic throughput measurements (>1000 ops/s)

**Actions**:

1. **JMH Configuration Review**:
   ```java
   @Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)
   @Measurement(iterations = 10, time = 10, timeUnit = TimeUnit.SECONDS)
   @Fork(value = 2, jvmArgsAppend = {"-Xmx256m", "-XX:+UseG1GC"})
   @Threads(8)
   ```

2. **Benchmark Infrastructure**:
   - Increase client-side resources
   - Use dedicated benchmark container
   - Separate measurement from application container

3. **Validation**:
   - Cross-check with wrk/ab tools
   - Monitor container metrics during benchmarks
   - Ensure no throttling occurs

=== Priority 4: HTTP/TLS Optimization

**Goal**: Reduce network overhead where possible

**Optimization Options**:

1. **HTTP/2 Multiplexing**:
   ```java
   HttpClient client = HttpClient.newBuilder()
       .version(HttpClient.Version.HTTP_2)
       .connectTimeout(Duration.ofSeconds(2))
       .build();
   ```

2. **Connection Pooling**:
   - Increase pool size for concurrent requests
   - Optimize keep-alive settings
   - Pre-warm connections on startup

3. **TLS Optimization**:
   - Enable TLS session resumption
   - Use TLS 1.3 for reduced handshake
   - Consider Unix Domain Sockets for local communication

== Success Metrics

=== Performance Targets

|===
| Metric | Current | Target | Priority
| **P95 Latency (JWT)** | 3.76ms | <5ms | ‚úÖ Achieved
| **P95 Latency (Health)** | 3.44ms | <5ms | ‚úÖ Achieved
| **P99 Latency (All)** | 155ms | <20ms | High
| **CPU Usage** | 69% | <40% | Critical
| **Memory Usage** | 95% | <70% | Critical
| **Throughput** | 2-7 ops/s | >1000 ops/s | Medium
|===

=== Validation Protocol

```bash
# Run comprehensive benchmarks
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-jmh -Pbenchmark

# Monitor resources during benchmark
docker stats --no-stream

# Analyze GC behavior
jfr print --events GarbageCollection jwt-benchmark.jfr
```

== Implementation Timeline

=== Week 1: Resource Optimization
- Day 1-2: Increase container resources
- Day 3-4: Implement memory configuration changes
- Day 5: Validate impact on P99 latency

=== Week 2: Performance Tuning
- Day 1-2: GC tuning and profiling
- Day 3-4: JMH configuration optimization
- Day 5: HTTP/TLS improvements

=== Week 3: Validation and Monitoring
- Day 1-2: Comprehensive benchmark suite
- Day 3-4: Performance dashboard setup
- Day 5: Documentation and knowledge transfer

== Expected Outcomes

With the proposed optimizations:

1. **Resource Utilization**:
   - CPU usage reduced to <40%
   - Memory usage reduced to <70%
   - Stable performance under load

2. **Latency Improvements**:
   - P99 reduced from 155ms to <20ms
   - Consistent sub-5ms P95 for all endpoints
   - Predictable performance characteristics

3. **Throughput Gains**:
   - Realistic measurement of >1000 ops/s
   - Better scalability with available resources
   - Improved concurrent request handling

4. **Operational Benefits**:
   - Reduced GC pressure and pauses
   - Better resource headroom for traffic spikes
   - Improved monitoring and observability

== Monitoring and Alerting

=== Key Metrics to Track

1. **Latency Metrics**:
   - P50, P95, P99 per endpoint
   - Bearer token validation duration
   - HTTP processing time

2. **Resource Metrics**:
   - CPU utilization and load average
   - Memory usage and GC frequency
   - Thread pool saturation

3. **Application Metrics**:
   - Request throughput
   - Error rates by category
   - Cache hit ratios

=== Alert Thresholds

- P95 latency > 5ms for >1 minute
- P99 latency > 20ms for >30 seconds
- CPU usage > 60% for >5 minutes
- Memory usage > 80% for >2 minutes
- Error rate > 5% for >1 minute

== Related Documentation

- **Microbenchmark Performance**: Core library optimization (separate track)
- **Benchmark Infrastructure**: JMH configuration and execution
- **Container Configuration**: Docker and OrbStack optimization
- **Native Image Tuning**: GraalVM and Quarkus native settings