= JWT Integration Test Latency Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Critical Build Information

**Build Commands:** 
```bash
# Run benchmarks with distroless containers (production testing)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-testing

# Run benchmarks with JFR profiling containers (performance analysis)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-jfr
```

**Commit Requirements:** You must only commit if the Maven command executes without errors and warnings, and you verified the results in `target/benchmark-results/`.

== Executive Summary

=== Current Performance Baseline (July 22, 2025)

**Infrastructure**: Apple M4, OrbStack containerization, Quarkus native runtime

|===
| Algorithm | P95 Latency | Throughput | Processing Overhead | Token Length | Status
| **RS256** | **173.0ms** | **1,413 req/sec** | **168.0ms** | 977 chars | ‚úÖ CURRENT
| **Health Check** | **5.0ms** | **26,104 req/sec** | **0ms (baseline)** | N/A | ‚úÖ BASELINE
|===

**Current Focus**: Reduce RS256 JWT validation latency from 173ms to <50ms through RSA-specific optimizations.

=== Quick Performance Summary

**RS256 Performance**: 173.0ms P95 latency, 1,413 req/sec throughput
**Target**: <50ms P95 latency (3.5x improvement needed)
**Bottleneck**: RSA signature verification (`BigInteger.modPow()` ~97% of time)

=== Infrastructure Optimization Status ‚úÖ **COMPLETED**

**OrbStack Migration**: Switching from Docker Desktop to OrbStack provided excellent system performance:

- Health Check: 5.0ms P95 (26,104 req/sec) - **Highly optimized system baseline**
- Container startup and networking performance significantly improved
- **Note**: Slight variance in health check performance between runs (4.1-5.0ms)

== Performance Analysis Summary

=== JFR Analysis Results ‚úÖ **COMPLETED**

**Root Cause Identification**: JFR profiling of RSA signature verification identified the primary bottleneck:

- **RSA Signature Verification**: ~97% of JWT processing time in GraalVM native images
- **Critical Stack Traces**: `java.math.BigInteger.modPow()` operations dominating CPU time
- **Evidence**: `sun.security.rsa.RSACore.crypt()` and `de.cuioss.jwt.validation.pipeline.TokenSignatureValidator.verifySignature()` as primary CPU consumers

**Performance Breakdown (RS256)**:

- System Infrastructure: 5.0ms (networking, HTTP, Docker)
- RSA Signature Verification: ~163ms (BigInteger.modPow operations)
- JWT Parsing/Validation: ~5ms (library logic)
- **Total**: 173.0ms P95

=== Critical Findings

1. **System Baseline**: 5.0ms P95 (health check) - Infrastructure is highly optimized
2. **JWT Processing**: 168.0ms additional overhead for RS256 (down from 500.8ms with ES256)
3. **Algorithm Impact**: RS256 performs 3.1x better than ES256 - **confirmed algorithmic difference**
4. **RSA Bottleneck**: `BigInteger.modPow()` operations consume ~97% of JWT validation time
5. **Migration Success**: Switching to RS256 reduced latency by 65.7% (504.9ms ‚Üí 173.0ms)

== Next Steps - Actionable Tasks

=== Priority 1: RSA Performance Optimization üöÄ **NEXT FOCUS**

**Goal**: Reduce RSA signature verification overhead from 168ms to target <50ms

**Current Status**: RS256 baseline established at 173.0ms P95 (1,413 req/sec)

**Next Optimization Paths**:

1. **GraalVM Native Image Tuning** ‚≠ê **IMMEDIATE ACTION**:
   ```bash
   # Add to native image build
   -march=native                    # ARM64 CPU-specific optimizations
   -O3                             # Maximum optimization level
   --pgo-instrument                # Generate PGO data
   --pgo=profile.iprof            # Use PGO data for RSA hotpaths
   ```

2. **Jipher JCE Provider Testing** (Oracle GraalVM):
   ```xml
   <!-- Add to pom.xml -->
   <dependency>
     <groupId>com.oracle.graalvm.jipher</groupId>
     <artifactId>jipher-jce</artifactId>
   </dependency>
   ```
   - Provides OpenSSL 3.0 native RSA implementation
   - Expected 2-5x performance improvement

3. **BigInteger.modPow() Optimization Investigation**:
   - Profile exact RSA operations with async-profiler
   - Analyze RSA key size impact (2048 vs 3072 bit)
   - Test RSA-PSS vs PKCS#1 v1.5 padding performance

**Target Performance**: 50ms P95 (requires 3.5x improvement from current 173.0ms)

=== Priority 2: Production Monitoring Setup üìä **REQUIRED**

**Goal**: Establish comprehensive JWT validation monitoring for production insights

**Implementation Tasks**:

1. **Micrometer Metrics Integration**:
   ```java
   @Timed(value = "jwt.validation.time", histogram = true)
   @Counted(value = "jwt.validation.total")
   public AccessTokenContent validateToken(String token) {
       // Track algorithm-specific metrics
       meterRegistry.counter("jwt.validation.algorithm", "type", algorithm).increment();
   }
   ```

2. **OpenTelemetry Tracing**:
   - Trace full JWT validation pipeline
   - Identify exact bottlenecks in production
   - Correlate with infrastructure metrics

3. **Custom JFR Events** (for better native image profiling):
   ```java
   @Name("jwt.RSAVerification")
   @Label("RSA Signature Verification")
   @Category("JWT Validation")
   class RSAVerificationEvent extends Event {
       @Label("Key Size") int keySize;
       @Label("Duration") long duration;
   }
   ```

**Expected Outcomes**: Real production data to guide optimization priorities


=== Priority 3: Benchmark Infrastructure Enhancement üîß

**Goal**: Improve measurement accuracy and coverage

**Tasks**:

1. **Warmup Period Implementation**:
   ```bash
   # Add warmup phase to benchmarks
   ./mvnw verify -Pbenchmark-jfr -Dwarmup.duration=60s -Dmeasurement.duration=120s
   ```

2. **Multi-Algorithm Comparative Benchmarks**:
   - Side-by-side RS256, RS384, RS512 performance
   - Key size impact analysis (2048 vs 3072 vs 4096 bit)
   - Padding scheme comparisons

3. **Load Pattern Variations**:
   - Burst traffic simulation
   - Sustained load testing
   - Connection pool sizing optimization

== Implementation Status

=== Completed Optimizations ‚úÖ

1. **Benchmark Infrastructure**: Maven-based execution with JFR profiling
2. **Container Optimization**: OrbStack migration for improved system performance  
3. **Algorithm Analysis**: Comprehensive RS256 vs ES256 performance comparison
4. **JFR Profiling**: Root cause identification (BigInteger.modPow bottleneck)
5. **ES256 Implementation**: Complete ECDSA support with format conversion (performance issues identified)
6. **Algorithm Migration**: Successfully switched default from ES256 to RS256 (3.1x improvement)
7. **Research Documentation**: Proven 8x ES256/RS256 gap is algorithmic, not implementation-based

=== Dismissed Items (Do Not Revisit)

==== 1. ES256 Algorithm Migration
**Status:** ‚ùå DISMISSED - ES256 performs 3x worse than RS256

**Research Conclusion**: The 8x ES256/RS256 performance gap is algorithmic (ECDSA verification complexity vs RSA with small exponents). Java ECDSA implementations are additionally 3x slower than native. Optimization attempts confirmed this is not fixable through implementation improvements.

==== 2. JWT Token Caching Implementation  
**Status:** ‚ùå DISMISSED - Processing time too high, caching won't solve core issue

==== 3. JWKS Key Retrieval Optimization
**Status:** ‚ùå DISMISSED - Already optimized and cached

==== 4. TLS/HTTPS Optimization
**Status:** ‚ùå DISMISSED - No TLS bottleneck identified (4.1ms health check baseline)