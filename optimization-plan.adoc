= JWT Integration Test Latency Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Critical Build Information

**Build Commands:** 
```bash
# Run benchmarks with distroless containers (production testing)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-testing

# Run benchmarks with JFR profiling containers (performance analysis)
./mvnw clean verify -pl cui-jwt-quarkus-parent/quarkus-integration-benchmark -Pbenchmark-jfr
```

**Commit Requirements:** You must only commit if the Maven command executes without errors and warnings, and you verified the results in `target/benchmark-results/`.

== Executive Summary

=== Current Performance Results

- **JWT Validation**: 195.6ms P95 (1,179 req/sec) - JFR-enabled native image
- **Health Check**: 24.4ms P95 (17,639 req/sec) - System baseline
- **JWT Processing Overhead**: 171.2ms (195.6ms - 24.4ms = JWT validation overhead)
- **Infrastructure**: Apple M4, containerized Quarkus native runtime with JFR support

=== Performance Targets

Based on 2024 Quarkus native benchmarks:

- **Our target**: 20ms total latency (achievable with proper optimization)
- **Health-check target**: <10ms (critical for production readiness)
- **Throughput target**: >1000 ops/s (currently achieved: 1,179 req/sec)

**Research findings:** Most 1-3ms benchmarks used HTTP. HTTPS adds ~5ms overhead.

== Completed Optimizations

=== JFR Native Image Implementation ✅ **COMPLETED**

Successfully implemented JFR support using dual-image approach with UBI-based containers for profiling.

**Current Status:**

- ✅ Multi-stage Docker build with Mandrel builder + dual runtime options
- ✅ Conditional JFR support via `ENABLE_JFR` build argument
- ✅ Runtime JFR configuration via `JFR_OPTS` environment variable
- ✅ Native executable built with `--enable-monitoring=heapdump,jfr`
- ✅ **JFR file generation working in UBI-based containers**
- ✅ **JFR recordings successfully collected for analysis (225KB file)**

**Solution**: Simplified Maven profiles (`integration-tests` and `jfr`) provide clean separation between production (distroless) and profiling (UBI-based) images with full JFR support.

=== Infrastructure Optimization ✅ **COMPLETED**

Significant performance improvements through Docker optimization:

- **Docker resource limits**: Memory 256MB→512MB, CPU 1.0→2.0 cores
- **wrk configuration**: Optimized from 6 threads/180 connections to 4 threads/80 connections
- **Health check improvement**: Reduced to 24.4ms P95 (system baseline)
- **Benchmark infrastructure**: Streamlined to profile-based execution

=== Tool Replacement and Real Token Enforcement ✅ **COMPLETED**

- Docker-based wrk solution implemented, replaced JMH for integration testing
- All mock token fallbacks removed, real token validation enforced
- Benchmark calculations verified - no calculation errors found

=== TLS/HTTPS Optimization ✅ **VERIFIED EXCELLENT**

HTTP vs HTTPS comparison test results (from earlier testing):

- HTTP P95 latency: 35.8ms
- HTTPS P95 latency: 33.9ms
- **Result**: HTTPS performs as well as HTTP (no TLS bottleneck)
- **Conclusion**: TLS is not a performance bottleneck in current setup

== Performance Analysis Summary

=== Key Insights

1. **System Baseline**: 23.7ms P95 (health check) - This is the infrastructure baseline
2. **JWT Processing**: 171.9ms additional overhead (195.6ms - 23.7ms)
3. **JWT Library**: ~5ms (micro-benchmark confirmed)
4. **Unknown Overhead**: 166.2ms (171.9ms - 5ms) - **REQUIRES JFR ANALYSIS**

=== Bottleneck Analysis

**Current Performance Breakdown:**

- **System Infrastructure**: 23.7ms (Docker, networking, HTTP processing)
- **JWT Library**: ~5ms (pure JWT validation)
- **Unknown Overhead**: 166.2ms (needs investigation)
- **Total**: 195.6ms P95

**Critical Finding**: The 166.2ms overhead requires JFR analysis to identify the root cause. This represents the difference between micro-benchmark performance and real-world execution patterns.

=== JFR Analysis Results (JVM Mode Reference)

JFR analysis on JVM mode identified potential bottlenecks:

1. **RSA Cryptographic Operations**: 85% of CPU time
2. **TLS/SSL Handshake Processing**: 12% of CPU time  
3. **Network I/O Operations**: 3% of CPU time

**Note**: This was JVM analysis. Native image performance patterns may differ significantly.

== Next Steps - Actionable Tasks

=== Priority 1: JFR Native Image Analysis ❌ **BLOCKED**

**Goal**: Identify the 166.2ms unknown overhead using JFR on native image

- [x] **JFR recording collection**: ❌ Failed due to distroless container limitations
- [x] **Performance hotspot analysis**: ❌ Unable to complete due to JFR recording failure
- [x] **Overhead categorization**: ❌ 166.2ms overhead remains unidentified
- [x] **JFR Limitations Analysis**: ✅ Documented native image JFR challenges

**Status**: BLOCKED - Cannot proceed without functional JFR recording

**Critical Findings**:

* **Unknown Overhead**: 166.2ms overhead (85% of JWT processing time) - **REQUIRES JFR ANALYSIS**
* **JFR Limitations**: Distroless containers + native images prevent JFR file generation
* **Next Steps**: Enable JFR recording to identify the actual performance bottleneck

**JFR Implementation Challenges**:

1. **File Permission Restrictions**: Distroless containers limit write access for JFR recordings
2. **Missing VM Events**: Native images lack most VM-internal events available in HotSpot
3. **No Runtime Control**: jcmd unavailable for JFR management in native images
4. **Limited Execution Sampling**: Stack traces and execution samples are restricted

**Next Steps for JFR Enablement**:

* **Primary Goal**: Resolve JFR file generation in distroless containers
* **Investigation**: Research alternative container configurations for JFR support
* **Fallback**: Consider non-distroless containers for JFR profiling phase

=== Priority 1: Enable JFR Recording via Maven Profiles ✅ **COMPLETED**

**Goal**: Resolve JFR file generation issues using Maven profiles for dual-image builds

**Solution Implemented**: Maven profiles with dual-stage Docker builds

- [x] **Maven Profile Configuration**: Created `docker-distroless` and `docker-jfr` profiles
- [x] **Multi-stage Dockerfile**: Supports both distroless and UBI-based targets
- [x] **UBI-based JFR Image**: Built-in JFR configuration with writable filesystem
- [x] **Build Verification**: Both variants build successfully with Maven
- [x] **JFR Recording Test**: ✅ Verified JFR files generated with UBI-based image (225KB file)
- [x] **Benchmark Execution**: ✅ Run performance test with distro-based JFR image

**Maven Commands**:

```bash
# Build distroless integration test containers
cd cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
./mvnw clean verify -Pintegration-tests

# Build JFR-enabled profiling containers  
cd cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
./mvnw clean verify -Pjfr

# Run benchmarks with distroless containers
cd cui-jwt-quarkus-parent/quarkus-integration-benchmark
./mvnw clean verify -Pbenchmark-testing

# Run benchmarks with JFR profiling containers
cd cui-jwt-quarkus-parent/quarkus-integration-benchmark
./mvnw clean verify -Pbenchmark-jfr
```

**Test Results**:

* **Build Time**: ~4m 30s for native image with JFR support
* **Image Sizes**: 187MB (JFR-enabled), 104MB (distroless)
* **JFR File Generated**: `jwt-distro-profile.jfr` (225KB)
* **Startup Time**: 0.296s (JFR-enabled native image)
* **JFR Recording Success**: ✅ UBI-based image successfully generates JFR files

=== Priority 2: Container Networking Analysis ✅ **DEPRIORITIZED**

**Goal**: Analyze if container networking contributes to the 166.2ms overhead

**Status**: Pending JFR analysis to determine if networking contributes to overhead

- [ ] **Container Network Analysis**: Measure inter-container communication latency
- [ ] **Docker Network Mode**: Test host networking vs bridge networking performance
- [ ] **Network I/O Profiling**: Analyze if JWKS endpoint calls contribute to overhead

=== Priority 3: Runtime Configuration Optimization

**Goal**: Fine-tune runtime settings to reduce overhead

- [ ] **Virtual thread configuration**: Verify optimal thread pool settings
- [ ] **GraalVM native settings**: Optimize native image compilation flags
- [ ] **Quarkus configuration**: Optimize framework-specific performance settings
- [ ] **Memory allocation**: Analyze native image memory usage patterns

=== Priority 4: Resource Constraints Analysis

**Goal**: Ensure Docker resource allocation is not causing overhead

- [ ] **Docker resource limits**: Review CPU/memory limits impact on latency
- [ ] **Container resource allocation**: Optimize Docker CPU and memory settings
- [ ] **CPU throttling detection**: Analyze and prevent CPU throttling events
- [ ] **Memory pressure monitoring**: Ensure no memory-induced delays

=== Priority 5: Advanced Optimization (If Needed)

**Goal**: Apply targeted optimizations based on JFR findings

- [ ] **Certificate optimization**: Only if JFR shows certificate processing overhead
- [ ] **Connection pooling**: Only if JFR shows connection management overhead
- [ ] **Thread optimization**: Only if JFR shows threading bottlenecks
- [ ] **Memory optimization**: Only if JFR shows GC or allocation overhead

== Dismissed Items (Do Not Revisit)

=== Items Already Ruled Out

==== 1. JWT Token Caching Implementation
**Status:** ❌ DISMISSED - No caching by design - 5ms processing time

==== 2. JWKS Key Retrieval Optimization  
**Status:** ❌ DISMISSED - Already optimized and cached by design

==== 3. Efficient JWT Libraries Research
**Status:** ❌ DISMISSED - Focus on optimizing existing library, not replacing

==== 4. Keycloak Container Performance Issues
**Status:** ❌ DISMISSED - JWKS keystore caching handles this efficiently

==== 5. Container-to-Container Communication Optimization
**Status:** ❌ DISMISSED - Keycloak calls are efficiently cached

==== 6. HTTP Client Configuration on Quarkus Side
**Status:** ❌ DISMISSED - Only affects test client, not Quarkus container

==== 7. Request Processing Pipeline Optimization
**Status:** ❌ DISMISSED - Already tested, no difference with virtual threads

==== 8. Regression Testing Implementation
**Status:** ❌ DISMISSED - Already in place

==== 9. Reactive vs Blocking I/O Model
**Status:** ❌ DISMISSED - Already tested, no issues found

==== 10. Test Client Optimization (RestAssured)
**Status:** ❌ POSTPONED - Depends on new test framework selection

==== 11. 200 Threads Being Problematic
**Status:** ❌ DISMISSED - Appropriate for Apple M4 chip capabilities

==== 12. Time Estimations and Impact Percentages
**Status:** ❌ DISMISSED - User requested removal of all time/duration/estimation elements