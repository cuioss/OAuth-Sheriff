= JWT Microbenchmark Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Executive Summary of Latest Findings (July 27, 2025)

=== 🔴 **CRITICAL DISCOVERY: 20x Performance Gap & 95.5% Thread Efficiency Loss**

Our comprehensive JFR-instrumented benchmark analysis reveals:

* **Component-level performance**: 95-177μs per JWT validation
* **System-level performance**: 1,927-3,460μs per operation (20x overhead)
* **Thread efficiency**: Only 4.5% with 200 threads
* **Primary bottleneck**: Signature validation (73.7% of time)
* **Root cause**: Unknown - requires deep investigation

=== Key Performance Metrics

|===
| Metric | Value | Impact
| **Thread Efficiency** | 4.5% (200 threads) | 🔴 95.5% capacity lost
| **Signature Validation** | 73.7% of time | 🔴 Primary bottleneck - root cause unknown
| **Performance Variance** | CV: 197-335% | 🔴 Extremely unstable
| **JFR vs Standard** | +74% throughput | 🟡 Measurement anomaly
| **Error Handling Impact** | 4.7-8.4% | ✅ Efficient, no optimization needed
|===

== Action Items Checklist - Updated Priority

=== 🔴 HIGHEST PRIORITY - Signature Validation Root Cause Analysis

- [ ] **Research JWT Libraries Signature Implementation** - Deep analysis of how competitors handle RSA verification
  - [ ] Analyze **jjwt** signature validation approach
  - [ ] Analyze **smallrye-jwt** signature validation approach  
  - [ ] Analyze **jose4j** signature validation approach
  - [ ] Document key differences in JCA usage patterns
  - [ ] Identify reuse strategies for Signature instances

- [ ] **Profile Current Signature Validation** - Identify the actual bottleneck
  - [ ] Add JFR custom events around `Signature.initVerify()` at line 186
  - [ ] Measure cost of Signature instance creation vs reuse
  - [ ] Profile `signatureTemplateManager.getSignatureInstance()` overhead
  - [ ] Check if public key initialization is the bottleneck
  - [ ] Analyze thread safety implications of Signature reuse

- [ ] **Investigate Signature Instance Reuse** - Suspected performance killer
  ```java
  // Current code at TokenSignatureValidator.java:186
  Signature verifier = signatureTemplateManager.getSignatureInstance(algorithm);
  verifier.initVerify(publicKey);  // Reinitializing every time - potential bottleneck?
  ```
  - [ ] Test if Signature instances can be cached per algorithm
  - [ ] Investigate thread-local Signature instance pooling
  - [ ] Measure performance impact of reuse vs recreation

=== 🔴 HIGH PRIORITY - JCA Performance Investigation

- [ ] **Deep Dive into JCA Provider Performance**
  - [ ] Profile default SunRsaSign provider performance
  - [ ] Analyze BigInteger.modPow hot spots
  - [ ] Check for lock contention in JCA internals
  - [ ] Compare single-threaded vs multi-threaded JCA performance

- [ ] **Benchmark Signature Operations in Isolation**
  - [ ] Create micro-benchmark for just RSA signature verification
  - [ ] Test with different key sizes (2048, 3072, 4096)
  - [ ] Compare performance with/without provider caching
  - [ ] Measure impact of security provider ordering

=== 🟡 MEDIUM PRIORITY - Thread Contention Analysis (After Root Cause Found)

- [ ] **Thread Scaling Analysis** - Only after signature bottleneck is understood
- [ ] **Profile Lock Contention** - Focus on JCA-related locks
- [ ] **Analyze Synchronization Points** - Especially in security providers

=== 🟡 MEDIUM PRIORITY - Memory Allocation & GC Pressure

- [ ] **Object Pooling for TokenBuilder** - P99: 133ms indicates severe GC issues
- [ ] **Profile GC Logs** - Enable -XX:+PrintGC in benchmarks
- [ ] **Reduce Allocation Rate** - Target <100MB/s per thread

=== 🟢 LOW PRIORITY - Deferred Optimizations

- [ ] **Signature Cache Implementation** - Only after root cause is fixed
  - Note: Must use standard Java collections (LinkedHashMap with LRU)
  - No external dependencies due to Quarkus native constraints
- [ ] **Pool HashMap Instances** - After primary bottleneck resolved

=== ✅ COMPLETED - Previous Optimizations

- [x] ✅ **COMPLETED** Add JFR instrumentation to measure operation variance
- [x] ✅ **COMPLETED** Deep analysis of source code using ULTRATHINK
- [x] ✅ **COMPLETED** Identified 27+ time system calls causing variance
- [x] ✅ **COMPLETED** Implemented ValidationContext to cache current time
- [x] ✅ **COMPLETED** Eliminated 3 critical OffsetDateTime.now() calls

== Research Tasks - JWT Library Comparison

=== Task 1: Analyze jjwt Signature Validation

**Repository**: https://github.com/jwtk/jjwt

**Research Questions**:
1. How does jjwt handle Signature instance creation?
2. Do they cache or pool Signature instances?
3. What's their approach to thread safety?
4. How do they initialize public keys?

**Key Files to Analyze**:
- `DefaultJwtParser.java`
- `RsaSignatureValidator.java` (or equivalent)
- Security provider management

=== Task 2: Analyze smallrye-jwt Signature Validation

**Repository**: https://github.com/smallrye/smallrye-jwt

**Research Questions**:
1. Integration with MicroProfile JWT
2. Signature verification implementation
3. Performance optimizations used
4. Thread safety approach

**Key Areas**:
- RSA signature validation
- Provider management
- Instance reuse patterns

=== Task 3: Analyze jose4j Signature Validation

**Repository**: https://bitbucket.org/b_c/jose4j

**Research Questions**:
1. How does jose4j optimize signature verification?
2. Caching strategies employed
3. JCA provider usage patterns
4. Performance considerations documented

=== Expected Findings

Based on the 73.7% time spent in signature validation, we expect to find:

1. **Signature Instance Reuse** - Other libraries likely cache Signature instances
2. **Provider Optimization** - Specific provider selection for performance
3. **Thread-Local Patterns** - Avoiding synchronization in JCA calls
4. **Key Initialization** - Optimized public key handling

== Detailed Performance Analysis

=== Signature Validation Bottleneck (73.7% of time)

**Current Implementation Analysis**:
```java
// TokenSignatureValidator.java:185-186
Signature verifier = signatureTemplateManager.getSignatureInstance(algorithm);
verifier.initVerify(publicKey);
```

**Potential Issues**:
1. **Instance Creation Overhead** - Creating new Signature instance per validation
2. **Public Key Initialization** - RSA key initialization is expensive
3. **Provider Lookup** - Security provider resolution per operation
4. **Thread Contention** - JCA internal locks under high concurrency

**Benchmark Data Supporting This**:
- Single operation: 70-110μs
- Under 200 threads: Efficiency drops to 4.5%
- Variance: 145-187x between P50 and P99

=== Component Performance Breakdown

|===
| Operation | Time (μs) | % of Total | Investigation Priority
| **Signature Validation** | 70-110 | 73.7% | 🔴 **CRITICAL - Root cause unknown**
| Token Building | 9-24 | 9.5% | 🟡 Secondary
| Token Parsing | 6-21 | 6.3% | 🟢 Acceptable
| Claims Validation | 5-12 | 5.3% | 🟢 Acceptable
| Other Operations | <1 | <1% | ✅ No action
|===

== Implementation Plan

=== Phase 1: Root Cause Analysis (1 week)

1. **Library Research** (2-3 days)
   - Deep dive into jjwt, smallrye-jwt, jose4j
   - Document signature validation patterns
   - Identify optimization techniques

2. **JCA Profiling** (2-3 days)
   - Add detailed JFR events to signature validation
   - Profile Signature instance lifecycle
   - Measure initialization vs verification time

3. **Prototype Solutions** (1-2 days)
   - Test Signature instance reuse
   - Benchmark thread-local caching
   - Validate thread safety

=== Phase 2: Implementation (1-2 weeks)

Based on findings from Phase 1:

1. **Implement Signature Optimization**
   - Apply discovered patterns from other libraries
   - Ensure thread safety
   - Maintain Quarkus native compatibility

2. **Validation & Testing**
   - Benchmark improvements
   - Verify thread safety
   - Test with various thread counts

=== Phase 3: Secondary Optimizations (2-3 weeks)

Only after signature validation is fixed:

1. **Memory Optimization**
   - Object pooling with standard Java
   - GC tuning

2. **Thread Optimization**
   - Optimal thread count determination
   - Lock contention reduction

== Validation Methodology

=== Focused Benchmarking

```bash
# Signature validation micro-benchmark
mvn verify -Pbenchmark \
  -Djmh.includes=".*SignatureValidation.*" \
  -Djmh.prof=jfr \
  -Djmh.iterations=10

# After optimization
mvn verify -Pbenchmark \
  -Djmh.threads=1,10,50,100,200 \
  -Djmh.iterations=10
```

=== Success Metrics

|===
| Metric | Current | Target | Priority
| Signature Validation Time | 70-110μs | <20μs | 🔴 Critical
| Thread Efficiency | 4.5% | >50% | 🔴 Critical
| P99 Latency | 147ms | <5ms | 🟡 High
| Throughput (50 threads) | ~25k ops/s | 200k ops/s | 🟡 High
|===

== Dismissed Optimization Approaches

=== Native Crypto / Hardware Acceleration
**Status:** ❌ DISMISSED - Docker environment constraint

**Reason:** Focus on Docker-compatible solutions. Hardware acceleration not portable across container environments.

=== Caffeine Cache
**Status:** ❌ DISMISSED - Quarkus native constraints

**Reason:** External dependencies not compatible with Quarkus native compilation. Must use standard Java collections.

=== Extended Thread Scaling Without Root Cause
**Status:** ❌ DISMISSED - Premature optimization

**Reason:** Thread scaling analysis only makes sense after understanding why signature validation consumes 73.7% of time.

=== Alternative JCA Providers
**Status:** ❌ DISMISSED - Complexity and compatibility

**Reason:** Focus on optimizing default provider usage first. Alternative providers add complexity and may not be available in all environments.

== Conclusion

The JWT validation library's performance is dominated by signature validation (73.7% of time). Before any other optimization, we must understand why signature validation is so expensive compared to other JWT libraries.

**Immediate Actions**:
1. **Research** how jjwt, smallrye-jwt, and jose4j handle signature validation
2. **Profile** the current implementation with focus on Signature instance lifecycle
3. **Test** signature instance reuse patterns for thread safety and performance

**Expected Outcome**:
Based on the extreme performance difference (73.7% of time), we likely will find that other libraries reuse Signature instances while we recreate them for every validation. Fixing this could reduce signature validation time by 50-80%.