= JWT Microbenchmark Optimization Plan
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Executive Summary of Latest Findings (July 27, 2025)

=== 🔴 CRITICAL DISCOVERY: 20x Performance Gap & 95.5% Thread Efficiency Loss

Our comprehensive JFR-instrumented benchmark analysis reveals:

* *Component-level performance*: 95-177μs per JWT validation
* *System-level performance*: 1,927-3,460μs per operation (20x overhead)
* *Thread efficiency*: Only 4.5% with 200 threads
* *Primary bottleneck*: Signature validation (73.7% of time)
* *Root cause*: JCA Provider contention and Signature instance creation overhead

=== Key Performance Metrics

|===
| Metric | Value | Impact
| *Thread Efficiency* | 4.5% (200 threads) | 🔴 95.5% capacity lost
| *Signature Validation* | 73.7% of time | 🔴 Primary bottleneck - JCA Provider contention
| *Performance Variance* | CV: 197-335% | 🔴 Extremely unstable
| *JFR vs Standard* | +74% throughput | 🟡 Measurement anomaly
| *Error Handling Impact* | 4.7-8.4% | ✅ Efficient, no optimization needed
|===

== Action Items Checklist - Updated Priority

=== 🔴 HIGHEST PRIORITY - Signature Validation Root Cause Analysis

- [x] *Research JWT Libraries Signature Implementation* ✅ COMPLETED
  - [x] Analyze *jjwt* signature validation approach - Uses standard JCA, no Signature caching
  - [x] Analyze *smallrye-jwt* signature validation approach - Uses Jose4j, Provider contention issue
  - [x] Analyze *jose4j* signature validation approach - Flexible JCA provider configuration
  - [x] Document key differences in JCA usage patterns - All use JCA, no custom crypto
  - [x] Identify reuse strategies for Signature instances - None found, all create new instances

- [ ] *Profile Current Signature Validation* - Identify the actual bottleneck
  - [ ] Add JFR custom events around `Signature.initVerify()` at line 186
  - [ ] Measure cost of Signature instance creation vs reuse
  - [ ] Profile `signatureTemplateManager.getSignatureInstance()` overhead
  - [ ] Check if public key initialization is the bottleneck
  - [ ] Analyze thread safety implications of Signature reuse

- [ ] *Investigate Signature Instance Reuse* - Suspected performance killer
+
[source,java]
----
// Current code at TokenSignatureValidator.java:186
Signature verifier = signatureTemplateManager.getSignatureInstance(algorithm);
verifier.initVerify(publicKey);  // Reinitializing every time - potential bottleneck?
----
  - [ ] Test if Signature instances can be cached per algorithm
  - [ ] Investigate thread-local Signature instance pooling
  - [ ] Measure performance impact of reuse vs recreation

=== 🔴 HIGHEST PRIORITY - Implementation Tasks

- [ ] *Thread-Safe Verifier Reuse Implementation*
  - [ ] Compare Auth0 approach (thread-safe JWTVerifier instances) with Tomitribe approach (immutable Signer instances)
  - [ ] Choose most promising variant based on:
    * Thread safety guarantees
    * Performance characteristics
    * Implementation complexity
    * Compatibility with existing architecture
  - [ ] Implement proof-of-concept for chosen approach
  - [ ] Benchmark against current implementation
  - [ ] Validate thread safety under high concurrency

- [ ] *Provider Caching Implementation* 
  - [ ] Implement Provider instance caching per algorithm (as identified by SmallRye JWT issue #179)
  - [ ] Pre-initialize providers for known algorithms:
    * RS256, RS384, RS512
    * ES256, ES384, ES512
    * PS256, PS384, PS512
  - [ ] Measure reduction in `Provider.getService()` synchronization overhead
  - [ ] Ensure compatibility with security provider ordering

- [ ] *Virtual Thread Optimization Investigation*
  - [ ] Research Scoped Values (JEP 429) as alternative to ThreadLocal for Virtual Threads
  - [ ] Evaluate compatibility with current JDK version
  - [ ] Design pattern for Signature instance management with Scoped Values
  - [ ] If not viable, move to dismissed optimizations

=== 🔴 HIGH PRIORITY - JCA Performance Investigation

- [ ] *Deep Dive into JCA Provider Performance*
  - [ ] Profile default SunRsaSign provider performance
  - [ ] Analyze BigInteger.modPow hot spots
  - [ ] Check for lock contention in JCA internals
  - [ ] Compare single-threaded vs multi-threaded JCA performance

- [ ] *Benchmark Signature Operations in Isolation*
  - [ ] Create micro-benchmark for just RSA signature verification
  - [ ] Test with different key sizes (2048, 3072, 4096)
  - [ ] Compare performance with/without provider caching
  - [ ] Measure impact of security provider ordering

=== 🟡 MEDIUM PRIORITY - Thread Contention Analysis (After Root Cause Found)

- [ ] *Thread Scaling Analysis* - Only after signature bottleneck is understood
- [ ] *Profile Lock Contention* - Focus on JCA-related locks
- [ ] *Analyze Synchronization Points* - Especially in security providers

=== 🟡 MEDIUM PRIORITY - Memory Allocation & GC Pressure

- [ ] *Object Pooling for TokenBuilder* - P99: 133ms indicates severe GC issues
- [ ] *Profile GC Logs* - Enable -XX:+PrintGC in benchmarks
- [ ] *Reduce Allocation Rate* - Target <100MB/s per thread

=== 🟢 LOW PRIORITY - Deferred Optimizations

- [ ] *Signature Cache Implementation* - Only after root cause is fixed
  - Note: Must use standard Java collections (LinkedHashMap with LRU)
  - No external dependencies due to Quarkus native constraints
- [ ] *Pool HashMap Instances* - After primary bottleneck resolved

=== ✅ COMPLETED - Previous Optimizations

- [x] ✅ *COMPLETED* Add JFR instrumentation to measure operation variance
- [x] ✅ *COMPLETED* Deep analysis of source code using ULTRATHINK
- [x] ✅ *COMPLETED* Identified 27+ time system calls causing variance
- [x] ✅ *COMPLETED* Implemented ValidationContext to cache current time
- [x] ✅ *COMPLETED* Eliminated 3 critical OffsetDateTime.now() calls

== Research Tasks - JWT Library Comparison

=== Task 1: Analyze jjwt Signature Validation ✅ COMPLETED

*Repository*: https://github.com/jwtk/jjwt

*Research Questions*:

. How does jjwt handle Signature instance creation?
. Do they cache or pool Signature instances?
. What's their approach to thread safety?
. How do they initialize public keys?

*Key Files to Analyze*:

* `DefaultJwtParser.java`
* `RsaSignatureValidator.java` (or equivalent)
* Security provider management

*Findings*:

* *Header Caching*: Issue #652 (https://github.com/jwtk/jjwt/issues/652) discusses caching JWT headers for 8-10% performance improvement
* *I/O Optimization*: Recent versions improved I/O efficiency with streams and buffers, achieving 15-20% performance improvements
* *Signature Instance Caching*: No explicit Signature instance caching found in the library
* *Thread Safety*: Not specifically documented for Signature handling
* *Related Resources*:
** Java JWT Benchmark showing JJWT performance: https://github.com/skjolber/java-jwt-benchmark

=== Task 2: Analyze smallrye-jwt Signature Validation ✅ COMPLETED

*Repository*: https://github.com/smallrye/smallrye-jwt

*Documentation*: https://smallrye.io/docs/smallrye-jwt/index.html

*Research Questions*:

. Integration with MicroProfile JWT
. Signature verification implementation
. Performance optimizations used
. Thread safety approach

*Key Areas*:

* RSA signature validation
* Provider management
* Instance reuse patterns

*Findings*:

* *MicroProfile JWT Implementation*: Full implementation of Eclipse MicroProfile JWT RBAC
* *Configuration*: Extensive configuration options for JWT validation (https://smallrye.io/docs/smallrye-jwt/configuration.html)
* *Performance Optimizations*: No specific RSA optimization details found in available documentation
* *Related Resources*:
** WildFly MicroProfile JWT integration: https://github.com/wildfly/wildfly/blob/main/docs/src/main/asciidoc/_admin-guide/subsystem-configuration/MicroProfile_JWT.adoc

=== Task 3: Analyze jose4j Signature Validation

*Repository*: https://bitbucket.org/b_c/jose4j

*Research Questions*:

. How does jose4j optimize signature verification?
. Caching strategies employed
. JCA provider usage patterns
. Performance considerations documented

*Status*: Pending analysis

=== Expected Findings

Based on the 73.7% time spent in signature validation, we expect to find:

. *Signature Instance Reuse* - Other libraries likely cache Signature instances
. *Provider Optimization* - Specific provider selection for performance
. *Thread-Local Patterns* - Avoiding synchronization in JCA calls
. *Key Initialization* - Optimized public key handling

=== Cryptographic Implementation Analysis

==== CUI-JWT (Current Implementation)
* *Cryptographic Library*: Standard JCA (Java Cryptography Architecture)
* *Signature Instance Management*:
** Uses `SignatureTemplateManager` with caching optimization
** Caches algorithm mappings and PSS parameters
** Creates fresh `Signature` instances per operation via `Signature.getInstance()`
** Thread-safe through instance creation (no reuse)
* *Provider*: Default JCA providers (e.g., SunRsaSign, SunEC)
* *Performance Optimization*: Template caching for algorithm mappings, not Signature instances

==== JJWT
* *Cryptographic Library*: Standard JCA with optional Bouncy Castle
* *Architecture*:
** Uses JCA `Signature.getInstance()` for each operation
** Supports custom security providers via JCA
** Bouncy Castle required for EdDSA and PS256/384/512 on older JDKs
* *Thread Safety*: Creates new Signature instances per operation
* *Performance*: No Signature instance caching found, relies on JCA provider efficiency

==== Auth0 Java-JWT  
* *Cryptographic Library*: Standard JCA
* *Architecture*:
** Uses JCA for all cryptographic operations
** Algorithm class is thread-safe and reusable
** JWTVerifier instances are thread-safe (Issue #260)
* *Signature Handling*: Creates new Signature instances via JCA
* *Key Feature*: Thread-safe verifier instances can be reused across threads

==== SmallRye JWT
* *Cryptographic Library*: Jose4j library (which uses JCA underneath)
* *Architecture*:
** Delegates to Jose4j for JWT operations
** Jose4j uses standard JCA providers
* *Known Issue*: java.security.Provider contention (Issue #179)
** Synchronization bottleneck in Provider.getService()
** 166,894 calls to Provider.getService() observed in profiling
** Significant time spent in synchronized blocks
* *Proposed Fix*: Cache Provider instances per algorithm

==== Jose4j
* *Cryptographic Library*: Standard JCA with optional Bouncy Castle
* *Architecture*:
** Flexible JCA provider configuration
** Supports per-operation provider selection
** JCASupport utility for algorithm availability checking
* *Provider Management*:
** Can set providers globally or per-operation
** Bouncy Castle for algorithms not in standard JDK

==== Key Insights

. *All libraries use JCA*: No library implements custom cryptography
. *No Signature instance reuse*: Due to thread-safety constraints
. *Provider contention*: SmallRye JWT identified synchronization bottleneck
. *Thread safety approaches*:
** Create new Signature instances (most common)
** Thread-safe wrapper classes (Auth0)
** No evidence of ThreadLocal or pooling patterns

=== Additional Library Analysis

*Auth0 Java JWT*

* *Repository*: https://github.com/auth0/java-jwt
* *Thread Safety*: Issue #260 (https://github.com/auth0/java-jwt/issues/260) confirms JWTVerifier is thread-safe
* *Documentation*: Issue #419 (https://github.com/auth0/java-jwt/issues/419) documents thread-safety concerns

*Fast-JWT (Node.js reference)*

* *Repository*: https://github.com/nearform/fast-jwt
* *Key Innovation*: Implements LRU caching for verified tokens
* *Performance*: Significant improvements through token caching rather than Signature caching

*Tomitribe HTTP Signatures*

* *Repository*: https://github.com/tomitribe/http-signatures-java
* *Key Design*: Immutable, thread-safe Signer instances
* *Optimization*: Key verification optimized on construction

*Auth0 JWKS RSA Java*

* *Repository*: https://github.com/auth0/jwks-rsa-java
* *Caching*: Implements JWK caching to avoid network requests
* *Configuration*: Configurable cache size and TTL

=== Key Performance Insights from Java JWT Benchmark

*Source*: https://github.com/skjolber/java-jwt-benchmark

*Critical Findings*:

. *RSA Bottleneck*: Over 90% of CPU time spent on signature verification
. *Limited Optimization Potential*: Only ~5% headroom for RSA optimization
. *Best Performers*: FusionAuth and Auth0 java-jwt tied for fastest
. *Baseline Performance*: Pure RSA verifiers only 5% faster than full JWT libraries

==== Optimization Opportunities

Based on the analysis, the primary optimization opportunities are:

. *Provider Contention Mitigation* (SmallRye JWT approach):
** Cache Provider instances to avoid synchronized Provider.getService() calls
** Pre-initialize providers for known algorithms

. *Token Caching* (Fast-JWT approach):
** Cache verified tokens with time-sensitive claim handling
** Skip entire verification for recently validated tokens

. *Algorithm Mapping Optimization* (CUI-JWT current approach):
** Cache algorithm name mappings and parameters
** Avoid repeated string parsing and parameter creation

. *Thread-Safe Verifier Reuse* (Auth0 approach):
** Create reusable, thread-safe verifier instances
** Amortize initialization costs across multiple verifications

=== Thread Safety Analysis

*Java Cryptographic API Limitations*:

* *Signature class*: NOT thread-safe (confirmed by multiple sources)
* *Common Issues*:
** Issue #7 at https://github.com/joyent/java-http-signature/issues/7
** Android KeyStore Signature exceptions in multithreaded environments
* *Safe Patterns*:
.. ThreadLocal storage for Signature instances
.. Object pooling with proper synchronization
.. Create new instance per operation (current approach, but slow)

== Detailed Performance Analysis

=== Signature Validation Bottleneck (73.7% of time)

*Current Implementation Analysis*:

[source,java]
----
// TokenSignatureValidator.java:185-186
Signature verifier = signatureTemplateManager.getSignatureInstance(algorithm);
verifier.initVerify(publicKey);
----

*Potential Issues*:

. *Instance Creation Overhead* - Creating new Signature instance per validation
. *Public Key Initialization* - RSA key initialization is expensive
. *Provider Lookup* - Security provider resolution per operation
. *Thread Contention* - JCA internal locks under high concurrency

*Benchmark Data Supporting This*:
- Single operation: 70-110μs
- Under 200 threads: Efficiency drops to 4.5%
- Variance: 145-187x between P50 and P99

=== Component Performance Breakdown

|===
| Operation | Time (μs) | % of Total | Investigation Priority
| *Signature Validation* | 70-110 | 73.7% | 🔴 *CRITICAL - Root cause unknown*
| Token Building | 9-24 | 9.5% | 🟡 Secondary
| Token Parsing | 6-21 | 6.3% | 🟢 Acceptable
| Claims Validation | 5-12 | 5.3% | 🟢 Acceptable
| Other Operations | <1 | <1% | ✅ No action
|===

== Implementation Plan

=== Phase 1: Root Cause Analysis (1 week)

. *Library Research* (2-3 days)
** Deep dive into jjwt, smallrye-jwt, jose4j
** Document signature validation patterns
** Identify optimization techniques

. *JCA Profiling* (2-3 days)
** Add detailed JFR events to signature validation
** Profile Signature instance lifecycle
** Measure initialization vs verification time

. *Prototype Solutions* (1-2 days)
** Test Signature instance reuse
** Benchmark thread-local caching
** Validate thread safety

=== Phase 2: Implementation (1-2 weeks)

Based on findings from Phase 1:

. *Implement Signature Optimization*
** Apply discovered patterns from other libraries
** Ensure thread safety
** Maintain Quarkus native compatibility

. *Validation & Testing*
** Benchmark improvements
** Verify thread safety
** Test with various thread counts

=== Phase 3: Secondary Optimizations (2-3 weeks)

Only after signature validation is fixed:

. *Memory Optimization*
** Object pooling with standard Java
** GC tuning

. *Thread Optimization*
** Optimal thread count determination
** Lock contention reduction

== Validation Methodology

=== Focused Benchmarking

[source,bash]
----
# Signature validation micro-benchmark
mvn verify -Pbenchmark \
  -Djmh.includes=".*SignatureValidation.*" \
  -Djmh.prof=jfr \
  -Djmh.iterations=10

# After optimization
mvn verify -Pbenchmark \
  -Djmh.threads=1,10,50,100,200 \
  -Djmh.iterations=10
----

=== Success Metrics

|===
| Metric | Current | Target | Priority
| Signature Validation Time | 70-110μs | <20μs | 🔴 Critical
| Thread Efficiency | 4.5% | >50% | 🔴 Critical
| P99 Latency | 147ms | <5ms | 🟡 High
| Throughput (50 threads) | ~25k ops/s | 200k ops/s | 🟡 High
|===

== Dismissed Optimization Approaches

=== Native Crypto / Hardware Acceleration
*Status:* ❌ DISMISSED - Docker environment constraint

*Reason:* Focus on Docker-compatible solutions. Hardware acceleration not portable across container environments.

=== Caffeine Cache
*Status:* ❌ DISMISSED - Quarkus native constraints

*Reason:* External dependencies not compatible with Quarkus native compilation. Must use standard Java collections.

=== Extended Thread Scaling Without Root Cause
*Status:* ❌ DISMISSED - Premature optimization

*Reason:* Thread scaling analysis only makes sense after understanding why signature validation consumes 73.7% of time.

=== ThreadLocal Signature Instances
*Status:* ❌ DISMISSED - Virtual Threads incompatibility

*Reason:* ThreadLocal pattern is problematic with Virtual Threads. Scoped Values (JEP 429) are the recommended alternative for Virtual Thread environments. Additionally, ThreadLocal can cause memory leaks if not properly managed.

=== Alternative JCA Providers
*Status:* ❌ DISMISSED - Complexity and compatibility

*Reason:* Focus on optimizing default provider usage first. Alternative providers add complexity and may not be available in all environments.

== Conclusion

The JWT validation library's performance is dominated by signature validation (73.7% of time). Before any other optimization, we must understand why signature validation is so expensive compared to other JWT libraries.

*Immediate Actions*:

. *Research* how jjwt, smallrye-jwt, and jose4j handle signature validation
. *Profile* the current implementation with focus on Signature instance lifecycle
. *Test* signature instance reuse patterns for thread safety and performance

*Expected Outcome*:
Based on the extreme performance difference (73.7% of time), we likely will find that other libraries reuse Signature instances while we recreate them for every validation. Fixing this could reduce signature validation time by 50-80%.