= Task 3. Integrate SecurityEvents with Micrometer
:toc:
:toclevels: 3
:toc-title: Table of Contents
:sectnums:

include::task-completion-process.adoc[leveloffset=+1]

== Overview
[ ] *Priority:* Medium

*Description:* Implement metrics reporting for JWT validation events:

. Create a security event listener that subscribes to events from the SecurityEventCounter
. Map security events to appropriate Micrometer metrics:
+
--
* Counter for validation attempts (success/failure) - `cui.jwt.validation.attempts`
* Counter for specific validation error types - `cui.jwt.validation.errors`
* Timer for validation duration - `cui.jwt.validation.duration`
* Gauge for JWKS cache size - `cui.jwt.jwks.cache.size`
--
. Add tags/labels to metrics for better filtering:
+
--
* `issuer` - The issuer URL
* `event_type` - The type of security event
* `token_type` - The type of token (access, id, refresh)
* `result` - The validation result (success, failure)
--
. Ensure metrics follow Micrometer best practices (naming conventions, proper units)
. Provide documentation on available metrics with examples of Prometheus queries

*Rationale:* Integration with Micrometer allows applications to monitor JWT validation performance and issues in production. This is essential for detecting potential security problems, performance bottlenecks, or configuration issues.

== Implementation Steps

* [ ] Create SecurityEventMetricsCollector class that implements ApplicationEventListener<SecurityEvent>
* [ ] Inject MeterRegistry from Quarkus Micrometer extension
* [ ] Define appropriate metrics with consistent naming convention
* [ ] Implement event listener methods for different event types from SecurityEventCounter
* [ ] Add unit tests for metrics collection with mock MeterRegistry
* [ ] Create integration test with Micrometer test support
* [ ] Document all exposed metrics with example Prometheus queries

== Task Completion Checklist

*1. Verify Implementation:*
+
--
* [ ] Verify all implementation steps are completed
* [ ] Check code against Quarkus and CUI standards
* [ ] Ensure proper error handling and edge cases are covered
* [ ] Verify compatibility with both JVM and native mode
--

*2. Write Tests:*
+
--
* [ ] Write unit tests for all components
* [ ] Create integration tests for real-world scenarios
* [ ] Test with different configuration options
* [ ] Verify error cases and edge conditions
--

*3. Verify Documentation:*
+
--
* [x] Update all references in README.adoc
* [x] Update relevant documentation in doc/ directory
* [x] Check for outdated file paths or references
* [x] Ensure consistent naming across all documentation
* [x] Add examples for common use cases
--

*4. Update Status:*
+
--
* [ ] Mark the task as completed with [x]
* [ ] Add any notes about implementation challenges or decisions if needed
--

*5. Make a Full Build:*
+
--
* [ ] Run the the module build: `.cd cui-jwt-quarkus-parent && mvn clean install` (from project-root)
** [ ] Verify all tests pass
** [ ] Check for any warnings that should be addressed
** [ ] Verify code coverage meets standards
* [ ] Run the full build command: `./mvnw -Ppre-commit clean verify` (from project-root)
** [ ] Verify all tests pass
** [ ] Check for any warnings that should be addressed
--
