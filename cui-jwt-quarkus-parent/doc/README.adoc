= CUI JWT Quarkus Extension Documentation
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Overview

Complete documentation for the CUI JWT Quarkus extension - a comprehensive JWT validation library integrated with the Quarkus framework. The extension provides automatic configuration, health checks, metrics integration, and development UI components.

== Quick Links

* **xref:../cui-jwt-quarkus-integration-tests/README.adoc[Integration Tests]** - Comprehensive testing with Docker containers
* **link:https://github.com/cuioss/cui-llm-rules/tree/main/standards/cdi-quarkus/[CDI Quarkus Standards]** - Development standards and best practices

== Architecture & Implementation

=== Core Extension Architecture

The CUI JWT Quarkus extension provides comprehensive JWT validation capabilities through a modular architecture:

* **Extension Architecture**: Build-time vs runtime components
* **CDI Integration**: Automatic bean discovery and configuration
* **Native Image Support**: GraalVM native compilation optimization
* **DevUI Components**: Development interface with JSON-RPC services

=== Integration Components

* **xref:integration/quarkus-integration.adoc[Quarkus Framework Integration]** - Core extension architecture
* **xref:integration/health-checks.adoc[Health Checks]** - MicroProfile Health readiness and liveness probes
* **xref:integration/metrics-integration.adoc[Metrics Integration]** - Micrometer metrics for monitoring
* **xref:integration/https-integration-testing.adoc[HTTPS Integration Testing]** - TLS certificate management

== Configuration & Usage

=== Configuration Management

* **xref:configuration/testing-configuration.adoc[Testing Configuration]** - Test profile setup and token utilities
* **xref:configuration/maven-build-configuration.adoc[Maven Build Configuration]** - Project build setup
* **xref:configuration/native-image-configuration.adoc[Native Image Configuration]** - GraalVM compilation settings

=== Development Tools

* **xref:development/devui-implementation.adoc[DevUI Implementation]** - Web components and JSON-RPC services
* **xref:development/devui-testing.adoc[DevUI Testing]** - Development interface validation
* **xref:development/quarkus-test-setup.adoc[Quarkus Test Framework Setup]** - Test framework configuration

== Performance & Optimization

=== Performance Analysis

* **xref:performance/jwt-validation-performance.adoc[JWT Validation Performance]** - Performance baselines and metrics
* **xref:performance/native-optimization-guide.adoc[Native Optimization Guide]** - GraalVM build configuration
* **xref:performance/jfr-profiling-guide.adoc[JFR Profiling Guide]** - Performance analysis tools

== Integration Testing

=== Comprehensive Testing

The extension includes comprehensive integration testing in containerized environments:

* **Native Container Testing**: Production-like validation
* **HTTPS Configuration**: TLS certificate management
* **Health & Metrics Validation**: End-to-end monitoring verification
* **DevUI Testing**: Development interface validation
* **Performance Benchmarking**: Native vs JVM comparisons

For detailed examples, see xref:../cui-jwt-quarkus-integration-tests/README.adoc[Integration Tests].

== Standards Compliance

This extension follows the **link:https://github.com/cuioss/cui-llm-rules/tree/main/standards/cdi-quarkus/[CDI Quarkus Standards]** for:

* **Container Security**: OWASP-compliant Docker configurations
* **Native Image Optimization**: Single-execution Maven builds
* **Testing Patterns**: Structured test organization
* **Documentation Standards**: Consistent structure and cross-referencing

== Getting Started

Basic setup steps:

1. **Add the extension** to your Quarkus project
2. **Configure JWT validation** with issuer and JWKS settings
3. **Enable health checks** with `quarkus-smallrye-health`
4. **Add metrics monitoring** with `quarkus-micrometer`
5. **Use BearerToken CDI injection** for simplified token handling
6. **Test your setup** using the provided test utilities

For detailed configuration examples, see the xref:../cui-jwt-quarkus-integration-tests/README.adoc[Integration Tests] documentation.

=== BearerToken CDI Injection

The extension provides convenient CDI injection for validated bearer tokens with two approaches:

==== CDI Producer Injection (Recommended for simple usage)

[source,java]
----
@Inject
@BearerToken
private Instance<AccessTokenContent> accessToken;

@Inject
@BearerToken(requiredScopes = {"read", "write"})
private Instance<AccessTokenContent> tokenWithScopes;

@Inject
@BearerToken(requiredRoles = {"admin"})
private Instance<AccessTokenContent> tokenWithRoles;

@Inject
@BearerToken(requiredGroups = {"managers"})
private Instance<AccessTokenContent> tokenWithGroups;

@Inject
@BearerToken(
    requiredScopes = {"read"}, 
    requiredRoles = {"user"}, 
    requiredGroups = {"employees"}
)
private Instance<AccessTokenContent> tokenWithAllRequirements;
----

==== BearerTokenResult Injection (Recommended for detailed validation info)

[source,java]
----
@Inject
@BearerToken
private BearerTokenResult tokenResult;

@Inject
@BearerToken(requiredScopes = {"read", "write"})
private BearerTokenResult tokenResultWithScopes;

@Inject
@BearerToken(requiredRoles = {"admin"})
private BearerTokenResult tokenResultWithRoles;

@Inject
@BearerToken(requiredGroups = {"managers"})
private BearerTokenResult tokenResultWithGroups;

@Inject
@BearerToken(
    requiredScopes = {"read"}, 
    requiredRoles = {"user"}, 
    requiredGroups = {"employees"}
)
private BearerTokenResult tokenResultWithAllRequirements;
----

==== Usage in JAX-RS Endpoints

===== Simple CDI Producer Usage

[source,java]
----
@Path("/api")
@ApplicationScoped
public class MyEndpoint {

    @Inject
    @BearerToken(requiredScopes = {"read"})
    private Instance<AccessTokenContent> readToken;

    @GET
    @Path("/data")
    public Response getData() {
        if (readToken.isResolvable() && readToken.get() != null) {
            AccessTokenContent token = readToken.get();
            // Token is valid and has "read" scope
            return Response.ok("Data for user: " + token.getSubject()).build();
        } else {
            // Token missing, invalid, or lacks required scope
            return Response.status(401).entity("Unauthorized").build();
        }
    }
}
----

===== Detailed BearerTokenResult Usage

[source,java]
----
@Path("/api")
@ApplicationScoped
public class MyEndpoint {

    @Inject
    @BearerToken(requiredScopes = {"read"})
    private BearerTokenResult tokenResult;

    @GET
    @Path("/data")
    public Response getData() {
        switch (tokenResult.getStatus()) {
            case FULLY_VERIFIED:
                AccessTokenContent token = tokenResult.getAccessTokenContent().get();
                return Response.ok("Data for user: " + token.getSubject()).build();
            
            case PARSING_ERROR:
                // Handle parsing errors with detailed information
                EventType eventType = tokenResult.getErrorEventType().get();
                String message = tokenResult.getErrorMessage().get();
                return Response.status(401)
                    .entity("Token parsing failed: " + message)
                    .build();
            
            case CONSTRAINT_VIOLATION:
                // Handle missing scopes/roles/groups
                return Response.status(403)
                    .entity("Insufficient permissions")
                    .build();
            
            case NO_TOKEN_GIVEN:
                return Response.status(401)
                    .entity("No token provided")
                    .build();
            
            case COULD_NOT_ACCESS_REQUEST:
                return Response.status(500)
                    .entity("Request context unavailable")
                    .build();
            
            default:
                return Response.status(500)
                    .entity("Unknown validation error")
                    .build();
        }
    }
}
----

===== Direct Service Usage

[source,java]
----
@Path("/api")
@ApplicationScoped
public class MyEndpoint {

    @Inject
    private BearerTokenProducer tokenProducer;

    @GET
    @Path("/data")
    public Response getData() {
        BearerTokenResult result = tokenProducer.getBearerTokenResult(
            List.of("read"), 
            List.of("user"), 
            List.of("employees")
        );
        
        if (result.isSuccessful()) {
            AccessTokenContent token = result.getAccessTokenContent().get();
            return Response.ok("Data for user: " + token.getSubject()).build();
        } else {
            return Response.status(401)
                .entity("Token validation failed: " + result.getStatus())
                .build();
        }
    }
}
----

The `@BearerToken` annotation automatically:

* Extracts tokens from the `Authorization` header
* Validates JWT signatures and claims
* Checks scope, role, and group requirements
* Returns `null` for invalid or missing tokens (CDI producer)
* Provides detailed validation information via `BearerTokenResult`
* Provides request-scoped token instances

== Additional Resources

=== Log Messages

* **xref:LogMessages.adoc[Log Messages Reference]** - Complete logging reference for the extension

=== Support

* **Issues**: Report problems via project issue tracker
* **Standards**: Follow link:https://github.com/cuioss/cui-llm-rules/tree/main/standards/cdi-quarkus/[CDI Quarkus Standards]
* **Testing**: Use xref:../cui-jwt-quarkus-integration-tests/README.adoc[Integration Tests] as examples