= JFR Profiling Guide
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Purpose

This guide provides technical instructions for configuring and analyzing Java Flight Recorder (JFR) profiling for Quarkus JWT validation applications. It defines JFR configuration, data collection methods, and analysis techniques for performance optimization.

== Related Documentation

* xref:jwt-validation-performance.adoc[JWT Validation Performance] - Performance baselines and bottleneck analysis
* xref:native-optimization-guide.adoc[Native Optimization Guide] - GraalVM build configuration with JFR support
* xref:../integration/metrics-integration.adoc[Metrics Integration] - Performance monitoring integration

== JFR Configuration

=== Native Image JFR Support

**Build Configuration for JFR**:

[source,properties]
----
# application.properties
# Enable JFR monitoring in native image (2024-2025 best practices)
quarkus.native.monitoring=jfr
----

**Separate Dockerfile Approach (2025 Implementation)**:

Two optimized Dockerfiles provide purpose-built containers:

[source,dockerfile]
----
# Dockerfile.native.distroless (Production)
FROM quay.io/quarkus/ubi-quarkus-mandrel-builder-image:jdk-21 AS build
# Build without JFR support for minimal size
RUN mvnw compile quarkus:build -Dquarkus.native.enabled=true

FROM quay.io/quarkus/quarkus-distroless-image:2.0
COPY --from=build /build/target/*-runner /app/application
----

[source,dockerfile]
----
# Dockerfile.native.jfr (Profiling)
FROM quay.io/quarkus/ubi-quarkus-mandrel-builder-image:jdk-21 AS build
# Build with JFR support enabled
RUN mvnw compile quarkus:build -Dquarkus.native.enabled=true -Dquarkus.native.monitoring=jfr

FROM registry.access.redhat.com/ubi8/ubi-minimal:8.10
RUN microdnf install -y findutils procps-ng && microdnf clean all
# JFR-enabled entrypoint with profiling
ENTRYPOINT ["/app/application", "-XX:+FlightRecorder", \
  "-XX:StartFlightRecording=filename=/tmp/jfr-output/jwt-profile.jfr,dumponexit=true,duration=300s,settings=profile"]
----

**Native Image Build Requirements**:

* Mandrel 23.1.7+ with JFR support
* JFR monitoring enabled during native image compilation
* Minimum JDK 21 for full JFR feature support in native images
* Build time: ~4m 30s with JFR support
* Performance impact: Minimal overhead (0.263s startup time)

=== Runtime JFR Configuration

**Standard JFR Recording Parameters**:

[source,bash]
----
# Fixed duration recording (recommended for analysis)
./application -XX:StartFlightRecording=duration=60s,filename=jwt-profile.jfr,settings=profile

# Continuous recording with rotation
./application -XX:StartFlightRecording=duration=0,filename=jwt-profile-%t.jfr,maxsize=100M,maxage=1h

# High-detail recording for bottleneck analysis
./application -XX:StartFlightRecording=duration=120s,filename=jwt-detailed.jfr,settings=default
----

**Container JFR Configuration (Maven Integration)**:

[source,bash]
----
# Build and run JFR-enabled containers using Maven
cd cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
./mvnw clean verify -Pjfr

# JFR recording automatically starts and saves to /tmp/jfr-output/jwt-profile.jfr
# Recording duration is 300s by default (configurable in Dockerfile.native.jfr)

# JFR files are automatically extracted to target/jfr-results/ during Maven build

# Run benchmarks with JFR profiling
cd cui-jwt-quarkus-parent/quarkus-integration-benchmark  
./mvnw clean verify -Pbenchmark-jfr

# Manual extraction alternative (if needed)
docker cp cui-jwt-integration-tests:/tmp/jfr-output/jwt-profile.jfr ./target/jfr-results/
----

== Native Image JFR Challenges and Solutions

=== Confirmed Limitations in Distroless Containers

**Technical Challenges Identified** (July 2025):

* **File Permission Restrictions**: Distroless containers have limited write access for JFR recordings
* **Missing VM Events**: Most VM-internal events available in HotSpot JVM are missing in native images
* **No Runtime Control**: jcmd is unavailable for JFR management in native images
* **Limited Stack Traces**: Execution sampling and stack traces are restricted

**JFR Enablement Status**:

* ✅ **Native Image Built with JFR Support**: Successfully enabled `quarkus.native.monitoring=jfr`
* ✅ **JFR Environment Configuration**: Properly configured `JFR_OPTS` and volume mounts
* ❌ **JFR File Generation**: Not working in current distroless environment
* ❌ **Runtime JFR Control**: No jcmd support in native images

**Resolution Implemented (2025)**:

1. **Separate Dockerfile Approach**: Purpose-built containers with `Dockerfile.native.distroless` and `Dockerfile.native.jfr`
2. **UBI-based JFR Image**: Full JFR support with debugging tools (~189MB image)
3. **Production Distroless**: Minimal attack surface for production use (~104MB image)
4. **Automated JFR Extraction**: Maven profile handles JFR results collection

**Build Commands**:

[source,bash]
----
# Production build (distroless, 104MB, no JFR)
cd cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
./mvnw clean verify -Pintegration-tests

# Profiling build (UBI-based, 189MB, full JFR support)
cd cui-jwt-quarkus-parent/cui-jwt-quarkus-integration-tests
./mvnw clean verify -Pjfr

# Run benchmarks with distroless containers
cd cui-jwt-quarkus-parent/quarkus-integration-benchmark
./mvnw clean verify -Pbenchmark-testing

# Run benchmarks with JFR profiling containers
cd cui-jwt-quarkus-parent/quarkus-integration-benchmark
./mvnw clean verify -Pbenchmark-jfr
----


== Data Collection Methods

=== Automated Profiling

**Benchmark with JFR Recording**:

[source,bash]
----
# Execute automated profiling script
./scripts/jfr-profile-benchmark.sh

# Output files:
# - jfr-results/jwt-validation-profile.jfr
# - jfr-results/benchmark-with-jfr.log
----

**JFR Collection During Load Testing**:

[source,bash]
----
# Note: jcmd is not available for native images
# Use Maven profiles for automated JFR collection

# Run benchmark with JFR-enabled containers
cd cui-jwt-quarkus-parent/quarkus-integration-benchmark
./mvnw clean verify -Pbenchmark-jfr

# JFR files automatically generated in ./target/benchmark-results/
# JFR recordings extracted to integration-tests target/jfr-results/
----

=== Production JFR Collection

**On-Demand Profiling**:

[source,bash]
----
# Note: jcmd is not available for native images
# Use container restart with JFR enabled

# Stop current container
docker compose down

# Configure JFR recording
echo "ENABLE_JFR=true" > .env
echo "JFR_OPTS=-XX:+FlightRecorder -XX:StartFlightRecording=filename=/tmp/jfr-output/production-profile.jfr,dumponexit=true,duration=180s,settings=profile" >> .env

# Start with JFR recording
docker compose up -d

# Extract recording after completion
docker cp container:/tmp/jfr-output/production-profile.jfr ./
----

**Continuous Production Monitoring**:

[source,bash]
----
# Application startup with continuous JFR
./application \
  -XX:StartFlightRecording=duration=0 \
  -XX:FlightRecorderOptions=filename=jwt-continuous.jfr,maxsize=200M,maxage=2h
----

== JFR Analysis Techniques

=== Command Line Analysis

**Performance Summary Analysis**:

[source,bash]
----
# Generate JFR summary report
jfr summary jwt-profile.jfr

# Extract CPU hotspot information
jfr print --events CPUSample jwt-profile.jfr | head -50

# Memory allocation analysis
jfr print --events ObjectAllocationInNewTLAB jwt-profile.jfr

# Garbage collection impact
jfr print --events GCPhasePause jwt-profile.jfr
----

**JWT-Specific Analysis Commands**:

[source,bash]
----
# Method-level CPU profiling
jfr print --events MethodSample \
  --categories "Java Application" jwt-profile.jfr | \
  grep -E "(TokenValidator|JwksLoader|JsonParser)"

# I/O operations (JWKS loading)
jfr print --events SocketRead,SocketWrite,FileRead jwt-profile.jfr

# Thread allocation and management
jfr print --events ThreadAllocationStatistics jwt-profile.jfr
----

=== Visual Analysis with JDK Mission Control

**JMC Analysis Workflow**:

1. **Launch JMC**: Download from https://jdk.java.net/jmc/
2. **Load JFR File**: File → Open File → Select profile.jfr
3. **Navigate Analysis Tabs**:
   * **Method Profiling**: CPU hotspots in JWT validation pipeline
   * **Memory**: Object allocation patterns
   * **Garbage Collection**: GC overhead analysis
   * **I/O**: Network operations for JWKS loading

**Key Analysis Areas for JWT Validation**:

* **CPU Hotspots**: Focus on TokenValidator methods
* **Allocation Patterns**: Monitor JWT object creation
* **I/O Operations**: JWKS endpoint connectivity performance
* **Threading**: Virtual thread efficiency analysis

== JWT Performance Analysis Focus Areas

=== Current Performance Bottleneck Analysis

**Performance Breakdown** (Based on 2025 JFR Analysis):

- **JWT Validation**: 195.6ms P95 (1,179 req/sec)
- **Health Check**: 23.7ms P95 (20,301 req/sec) - System baseline
- **JWT Processing Overhead**: 171.9ms (195.6ms - 23.7ms)
- **JWT Library**: ~5ms (micro-benchmark confirmed)
- **Unknown Overhead**: 166.2ms (needs JFR investigation)

**Primary Analysis Targets**:

1. **Unknown Overhead Investigation** (166.2ms):
   * Requires JFR analysis to identify root cause
   * Likely cryptographic operations or container networking
   * Native image specific performance patterns

2. **RSA Cryptographic Operations** (JVM Analysis Reference):
   * 85% of CPU time in JVM mode
   * RSA private key operations, CRT optimizations
   * RSA-PSS signature generation

3. **TLS/SSL Processing** (JVM Analysis Reference):
   * 12% of CPU time in JVM mode
   * Certificate verification and chain processing
   * Note: Native image shows TLS performs well (no bottleneck)

**Critical Finding**: The 166.2ms unknown overhead is the primary optimization target. JFR analysis is required to identify whether this is due to cryptographic operations, container networking, or native image specific performance characteristics.

=== Memory Allocation Analysis

**Memory Profiling Focus**:

* **Object Creation Patterns**: JWT token object lifecycle
* **Garbage Collection Impact**: Memory pressure during validation
* **Caching Efficiency**: JWKS and configuration object reuse

**JFR Memory Analysis Commands**:

[source,bash]
----
# Allocation by class
jfr print --events ObjectAllocationInNewTLAB jwt-profile.jfr | \
  awk '{print $NF}' | sort | uniq -c | sort -nr | head -20

# Large object allocations
jfr print --events ObjectAllocationOutsideTLAB jwt-profile.jfr
----

=== Thread Performance Analysis

**Virtual Thread Analysis**:

[source,bash]
----
# Thread creation and management
jfr print --events ThreadStart,ThreadEnd jwt-profile.jfr

# Virtual thread scheduling efficiency
jfr print --events VirtualThreadStart,VirtualThreadEnd jwt-profile.jfr
----

**Concurrency Analysis Focus**:

* Thread pool utilization efficiency
* Lock contention in JWT validation pipeline
* Virtual thread scheduling overhead

== JFR Report Generation

=== Automated Report Generation

**Standard Performance Report**:

[source,bash]
----
# Generate comprehensive JFR analysis report
jfr print --events CPUSample,ObjectAllocationInNewTLAB,GCPhasePause \
  jwt-profile.jfr > jwt-performance-report.txt

# Extract method hotspots
jfr print --events MethodSample jwt-profile.jfr | \
  grep -E "TokenValidator|JwksLoader" > jwt-hotspots.txt
----

**Custom Analysis Scripts**:

[source,bash]
----
#!/bin/bash
# JWT-specific JFR analysis script
JFR_FILE=$1
OUTPUT_DIR="jfr-analysis"

mkdir -p $OUTPUT_DIR

# CPU analysis
jfr print --events CPUSample $JFR_FILE > $OUTPUT_DIR/cpu-analysis.txt

# Memory analysis
jfr print --events ObjectAllocationInNewTLAB $JFR_FILE > $OUTPUT_DIR/memory-analysis.txt

# I/O analysis
jfr print --events SocketRead,SocketWrite $JFR_FILE > $OUTPUT_DIR/io-analysis.txt

echo "Analysis complete in $OUTPUT_DIR/"
----

== JFR Best Practices

=== Production JFR Guidelines

**Performance Impact Considerations**:

* JFR overhead: <1% CPU impact with default settings
* Storage requirements: ~10-50MB per hour depending on load
* Network impact: Minimal for local file recording

**Recording Duration Guidelines**:

* **Bottleneck Analysis**: 60-120 seconds during peak load
* **Baseline Recording**: 5-10 minutes for comprehensive coverage
* **Continuous Monitoring**: Rotate files every 1-2 hours

=== JFR Security Considerations

**Data Privacy**:

* JFR files may contain sensitive method parameters
* Encrypt JFR files for secure storage and transmission
* Limit JFR access to authorized performance analysis personnel

**Production Recording Controls**:

[source,bash]
----
# Secure JFR recording with limited scope
./application -XX:StartFlightRecording=duration=60s,filename=secure-profile.jfr,settings=profile

# Disable sensitive event recording
-XX:FlightRecorderOptions=+StackTrace,-ClassLoading
----

== Troubleshooting JFR Issues

=== Common JFR Problems

**Native Image JFR Issues**:

* **Missing JFR Support**: Verify `--enable-monitoring=jfr` in build args
* **Recording Failures**: Check GraalVM/Mandrel version compatibility
* **Empty JFR Files**: Ensure sufficient recording duration

**JFR Analysis Issues**:

* **Large JFR Files**: Use filtering options to reduce file size
* **Missing Events**: Verify event categories are enabled
* **JMC Compatibility**: Ensure JMC version matches JFR format

=== Performance Impact Verification

**JFR Overhead Measurement**:

[source,bash]
----
# Baseline benchmark without JFR
./scripts/benchmark-with-monitoring.sh

# Benchmark with JFR recording
./application -XX:StartFlightRecording=duration=120s,filename=overhead-test.jfr &
./scripts/benchmark-with-monitoring.sh

# Compare results to measure JFR overhead
----

== See Also

* xref:jwt-validation-performance.adoc[JWT Validation Performance] - Performance baselines and bottleneck analysis
* xref:native-optimization-guide.adoc[Native Optimization Guide] - GraalVM configuration with JFR support
* xref:../integration/metrics-integration.adoc[Metrics Integration] - Alternative performance monitoring approaches