= JFR Profiling Guide for Quarkus JWT Validation
:toc: left
:toclevels: 3
:source-highlighter: rouge
:icons: font

== Overview

This guide provides comprehensive instructions for configuring, applying, and analyzing Java Flight Recorder (JFR) profiling for Quarkus JWT validation applications in production environments.

JFR is a low-overhead profiling tool that provides detailed insights into application performance, including CPU usage, memory allocation, garbage collection, and I/O operations.

== Prerequisites

* Quarkus 3.x with GraalVM native image support
* Oracle GraalVM or Mandrel with JFR support
* JDK Mission Control (JMC) for analysis (optional)
* Production environment with JFR capabilities

== JFR Configuration

=== Native Image Configuration

Add JFR support to your Quarkus native image build:

[source,properties]
----
# application.properties
quarkus.native.additional-build-args=--enable-monitoring=jfr
----

For comprehensive monitoring, include additional flags:

[source,properties]
----
quarkus.native.additional-build-args=--enable-url-protocols=https,--enable-http,--enable-https,--enable-monitoring=jfr,-O2
----

=== Runtime JFR Configuration

Configure JFR recording parameters for production use:

[source,bash]
----
# Start application with JFR recording
./application -XX:StartFlightRecording=duration=60s,filename=jwt-validation-profile.jfr,settings=profile

# Continuous recording with automatic rotation
./application -XX:StartFlightRecording=duration=0,filename=jwt-validation-%t.jfr,maxsize=100M,maxage=1h
----

=== Container Environment

For containerized deployments, configure JFR in your container runtime:

[source,dockerfile]
----
# Dockerfile
FROM quay.io/quarkus/quarkus-distroless-image:2.0
COPY --from=builder /project/application /app/application
ENTRYPOINT ["/app/application", "-XX:StartFlightRecording=duration=0,filename=/app/logs/jwt-profile.jfr,maxsize=50M"]
----

== JFR Data Collection

=== Automated Profiling Script

Use the provided automated profiling script:

[source,bash]
----
#!/bin/bash
# Located at: cui-jwt-quarkus-integration-tests/scripts/jfr-profile-benchmark.sh

# Execute automated profiling
./scripts/jfr-profile-benchmark.sh

# Results will be available in:
# - jfr-results/jwt-validation-profile.jfr
# - jfr-results/benchmark-with-jfr.log
----

=== Manual JFR Collection

For production environments, collect JFR data manually:

[source,bash]
----
# Start recording
jcmd <PID> JFR.start duration=300s filename=jwt-production-profile.jfr settings=profile

# Check recording status
jcmd <PID> JFR.check

# Stop recording
jcmd <PID> JFR.stop filename=jwt-production-profile.jfr
----

== JFR Analysis

=== Command Line Analysis

Use JFR command-line tools for quick analysis:

[source,bash]
----
# Generate summary report
jfr summary jwt-validation-profile.jfr

# Analyze CPU hotspots
jfr print --events CPUSample jwt-validation-profile.jfr

# Memory allocation analysis
jfr print --events ObjectAllocationInNewTLAB jwt-validation-profile.jfr

# Garbage collection analysis
jfr print --events GCPhasePause jwt-validation-profile.jfr

# I/O operations
jfr print --events FileRead,FileWrite,SocketRead,SocketWrite jwt-validation-profile.jfr
----

=== JDK Mission Control Analysis

For detailed visual analysis, use JDK Mission Control:

1. **Launch JMC**: `jmc` or download from https://jdk.java.net/jmc/
2. **Open JFR File**: File → Open File → Select `jwt-validation-profile.jfr`
3. **Key Analysis Areas**:
   * **Method Profiling**: Identify CPU hotspots in JWT validation
   * **Memory**: Analyze object allocation patterns
   * **Garbage Collection**: Review GC impact on performance
   * **I/O**: Examine JWKS fetching performance

=== JWT-Specific Analysis Focus

When analyzing JWT validation performance, focus on:

==== CPU Hotspots
* JWT signature verification methods
* JSON parsing operations
* Cryptographic operations (RSA, ECDSA)
* String manipulation and encoding/decoding

==== Memory Allocation
* Temporary objects during JWT parsing
* JSON deserialization overhead
* Cache object creation and retention
* HTTP client connection pooling

==== I/O Operations
* JWKS endpoint HTTP requests
* Certificate loading and parsing
* Network timeout patterns
* Connection reuse efficiency

== Performance Optimization Based on JFR Data

=== Common JWT Validation Bottlenecks

Based on JFR analysis, common performance issues include:

1. **Excessive Object Allocation**
   * Solution: Implement object pooling or caching
   * Example: Cache parsed JWT claims objects

2. **Inefficient JWKS Fetching**
   * Solution: Optimize HTTP client configuration
   * Example: Connection pooling, keep-alive settings

3. **CPU-Intensive Cryptographic Operations**
   * Solution: Use hardware acceleration where available
   * Example: Native cryptographic libraries

=== Configuration Optimizations

Apply these optimizations based on JFR findings:

[source,properties]
----
# Native Image Runtime Configuration
quarkus.native.container-runtime-options=-m=256m

# Virtual Threads Configuration for I/O operations
quarkus.virtual-threads.name-prefix=jwt-validation
quarkus.virtual-threads.shutdown-timeout=10s
----

== Production Monitoring

=== Continuous Profiling

Implement continuous profiling in production:

[source,bash]
----
# Cron job for regular profiling
0 */6 * * * jcmd $(pgrep -f jwt-validation) JFR.start duration=300s filename=/var/log/jwt-profile-$(date +%Y%m%d-%H%M).jfr settings=profile
----

=== Alert Configuration

Set up alerts based on JFR metrics:

* **High CPU Usage**: > 80% for JWT validation methods
* **Memory Allocation Rate**: > 100MB/s sustained
* **GC Pause Time**: > 100ms for serial GC
* **I/O Wait Time**: > 50ms for JWKS requests

== Troubleshooting

=== Common Issues

1. **JFR Not Available**
   * Verify GraalVM/Mandrel version supports JFR
   * Check native image build includes `--enable-monitoring=jfr`

2. **Large JFR Files**
   * Use sampling instead of continuous recording
   * Configure appropriate `maxsize` and `maxage` parameters

3. **Performance Impact**
   * JFR overhead is typically < 2% in production
   * Use 'default' settings for lower overhead vs 'profile' for detailed analysis

== References and Sources

* **Oracle JFR Documentation**: https://docs.oracle.com/en/java/javase/21/jfr/
* **Quarkus Native Image Guide**: https://quarkus.io/guides/building-native-image
* **GraalVM JFR Support**: https://www.graalvm.org/latest/reference-manual/native-image/JFR/
* **JDK Mission Control**: https://jdk.java.net/jmc/
* **Quarkus Performance Tuning**: https://quarkus.io/guides/performance-measure
* **JFR Events Reference**: https://bestsolution-at.github.io/jfr-doc/
* **GraalVM Native Image Monitoring**: https://www.graalvm.org/latest/reference-manual/native-image/guides/debug-native-image/
* **Quarkus Container Images**: https://quarkus.io/guides/container-image

== Implementation Notes

This guide is based on practical implementation experience with:

* **Quarkus 3.23.3** with native image support
* **GraalVM CE 21.0.2** and **Mandrel 23.1.2**
* **JFR support in native images** as of 2025
* **Production workloads** processing 200+ JWT validations per second
* **Container environments** with memory constraints

The profiling script (`jfr-profile-benchmark.sh`) referenced in this guide provides automated JFR data collection specifically optimized for JWT validation workloads.