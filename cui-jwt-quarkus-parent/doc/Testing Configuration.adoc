= JWT Quarkus Extension: Testing Guide
:toc: auto
:source-highlighter: highlightjs

== Overview

This concise guide explains how to test applications that use the `cui-jwt-quarkus` extension. It focuses on practical examples for writing effective tests with minimal configuration.

== Quick Start

=== Step 1: Add the Test Profile

Create a test profile that overrides JWT configuration properties for testing:

[source,java]
----
public class JwtTestProfile implements QuarkusTestProfile {
    @Override
    public Map<String, String> getConfigOverrides() {
        Map<String, String> config = new HashMap<>();
        
        // Test issuer configuration
        config.put("cui.jwt.issuers.default.url", "https://test.example.com/auth");
        config.put("cui.jwt.issuers.default.enabled", "true");
        config.put("cui.jwt.issuers.default.public-key-location", "");
        
        // Test parser configuration
        config.put("cui.jwt.parser.audience", "test-application");
        
        return config;
    }
}
----

=== Step 2: Apply the Profile to Tests

Use the `@TestProfile` annotation with your test class:

[source,java]
----
@QuarkusTest
@TestProfile(JwtTestProfile.class)
class MyJwtTest {
    
    @Inject
    TokenValidator tokenValidator;
    
    // Test methods...
}
----

=== Step 3: Create Test Tokens

Use the test utility classes to create JWT tokens for testing:

[source,java]
----
@Test
void shouldValidateTestToken() {
    // Create a test token with specific claims
    String token = TestTokenHolder.builder()
        .issuer("https://test.example.com/auth")
        .audience("test-application")
        .subject("test-user")
        .addClaim("scope", "read write")
        .build()
        .getToken();
    
    // Validate the token
    ValidationResult result = tokenValidator.validate(token);
    assertTrue(result.isValid());
}
----

== Testing Patterns

=== Testing with Mock Tokens

For basic validation testing, create tokens with the `TestTokenHolder`:

[source,java]
----
@Test
void shouldExtractClaims() {
    // Create token with custom claims
    String token = TestTokenHolder.builder()
        .issuer("https://test.example.com/auth")
        .audience("test-application")
        .addClaim("roles", Arrays.asList("admin", "user"))
        .addClaim("email", "test@example.com")
        .build()
        .getToken();
    
    // Validate and extract claims
    ValidationResult result = tokenValidator.validate(token);
    assertTrue(result.isValid());
    assertEquals("test@example.com", result.getClaims().get("email"));
    assertTrue(result.getClaims().get("roles") instanceof List);
}
----

=== Testing Configuration Injection

Verify that configuration is correctly injected and processed:

[source,java]
----
@QuarkusTest
@TestProfile(JwtTestProfile.class)
class ConfigurationTest {

    @Inject
    JwtValidationConfig config;
    
    @Test
    void shouldLoadTestConfiguration() {
        assertNotNull(config);
        assertEquals("https://test.example.com/auth", 
                    config.issuers().get("default").url());
        assertEquals("test-application", config.parser().audience());
    }
}
----

=== Testing Invalid Tokens

Test handling of invalid or tampered tokens:

[source,java]
----
@Test
void shouldRejectInvalidToken() {
    // Create a token then tamper with it
    String token = TestTokenHolder.builder()
        .issuer("https://test.example.com/auth")
        .build()
        .getToken();
    
    String tamperedToken = JwtTokenTamperingUtil.tamperWithPayload(token, 
                           claims -> claims.put("iss", "https://malicious.com"));
    
    ValidationResult result = tokenValidator.validate(tamperedToken);
    assertFalse(result.isValid());
    assertEquals("Invalid issuer", result.getErrorMessage());
}
----
== Advanced Testing Techniques

=== Using Test-Specific Properties

For more complex scenarios, override configuration in the test resources:

1. Create a test-specific `application.properties` in `src/test/resources`:

[source,properties]
----
# Override JWT configuration for tests
cui.jwt.issuers.default.url=https://test.example.com/auth
cui.jwt.issuers.default.enabled=true
cui.jwt.issuers.default.public-key-location=
cui.jwt.parser.audience=test-app
----

2. These properties will be automatically applied in tests.

=== Testing Multiple Issuers

Test configuration with multiple token issuers:

[source,java]
----
public class MultiIssuerTestProfile implements QuarkusTestProfile {
    @Override
    public Map<String, String> getConfigOverrides() {
        Map<String, String> config = new HashMap<>();
        
        // First issuer
        config.put("cui.jwt.issuers.issuer1.url", "https://auth1.example.com");
        config.put("cui.jwt.issuers.issuer1.enabled", "true");
        
        // Second issuer
        config.put("cui.jwt.issuers.issuer2.url", "https://auth2.example.com");
        config.put("cui.jwt.issuers.issuer2.enabled", "true");
        
        return config;
    }
}
----

Test tokens from different issuers:

[source,java]
----
@Test
void shouldValidateTokensFromMultipleIssuers() {
    // Create and validate token from first issuer
    String token1 = TestTokenHolder.builder()
        .issuer("https://auth1.example.com")
        .build()
        .getToken();
    ValidationResult result1 = tokenValidator.validate(token1);
    assertTrue(result1.isValid());
    
    // Create and validate token from second issuer
    String token2 = TestTokenHolder.builder()
        .issuer("https://auth2.example.com")
        .build()
        .getToken();
    ValidationResult result2 = tokenValidator.validate(token2);
    assertTrue(result2.isValid());
}
----

== Best Practices

1. **Explicitly Set Empty Values**: Always set empty string (`""`) instead of null for properties you want to disable
2. **Use TestProfile for Clarity**: Prefer `@TestProfile` over application.properties for test configuration
3. **Test All Token Types**: Test access tokens, ID tokens, and refresh tokens separately
4. **Validate Rejection Cases**: Test that invalid tokens are properly rejected
5. **Keep Tests Isolated**: Each test should create its own tokens with specific claims

== Common Pitfalls

1. **Missing Public Key Configuration**: Ensure `public-key-location` is explicitly set to empty string in tests
2. **Audience Mismatch**: Ensure the token audience matches the configured audience in test profile
3. **Token Expiration**: Be mindful of token expiration times in long-running tests
4. **Issuer URL Format**: Ensure the issuer URL in tokens exactly matches the configured URL

== Conclusion

Testing with the `cui-jwt-quarkus` extension is straightforward using Quarkus Test Profiles. By following the patterns in this guide, you can effectively test JWT validation in your applications with minimal configuration.
