= Developer Guide for cui-jwt-validation
:toc: left
:toclevels: 3
:sectnums:

This guide provides information for developers extending or integrating with the cui-jwt-validation library.

== Performance Metrics Infrastructure

The library includes a lightweight, thread-safe performance monitoring system in the `de.cuioss.jwt.validation.metrics` package for analyzing JWT validation performance.

=== TokenValidatorMonitor

`TokenValidatorMonitor` measures execution times for different JWT validation pipeline stages with microsecond precision:

[source,java]
----
// Create monitor with default window size (100 samples)
TokenValidatorMonitor monitor = new TokenValidatorMonitor();

// Record a measurement
long startNanos = System.nanoTime();
// ... perform signature validation ...
long durationNanos = System.nanoTime() - startNanos;
monitor.recordMeasurement(MeasurementType.SIGNATURE_VALIDATION, durationNanos);

// Get average for analysis
Duration avgSignatureTime = monitor.getAverageDuration(MeasurementType.SIGNATURE_VALIDATION);
----

=== MeasurementType

The `MeasurementType` enum defines measurable pipeline stages:

* `COMPLETE_VALIDATION` - End-to-end validation time
* `TOKEN_PARSING` - JWT structure validation and decoding
* `HEADER_VALIDATION` - Header claims validation
* `SIGNATURE_VALIDATION` - Cryptographic verification (typically most expensive)
* `CLAIMS_VALIDATION` - Token claims validation
* `JWKS_OPERATIONS` - Key loading and caching operations

=== Design Principles

* **Lock-free operations** - Uses atomic operations for minimal overhead
* **Rolling window sampling** - Maintains configurable number of recent measurements
* **Microsecond precision** - High-resolution timing for accurate analysis
* **Framework-agnostic** - No external dependencies, can integrate with Micrometer/Prometheus

== Security Event Monitoring

The `SecurityEventCounter` in `de.cuioss.jwt.validation.security` provides thread-safe counters for security events:

[source,java]
----
SecurityEventCounter counter = tokenValidator.getSecurityEventCounter();

// Get current counts
long invalidTokens = counter.getCount(EventType.INVALID_JWT_FORMAT);
Map<EventType, Long> allCounts = counter.getCounters();

// Reset counters if needed
counter.reset(EventType.INVALID_JWT_FORMAT);
----

Event types are categorized by `EventCategory`:

* `INVALID_STRUCTURE` - Malformed tokens, size violations
* `INVALID_SIGNATURE` - Signature verification failures
* `SEMANTIC_ISSUES` - Expired tokens, audience mismatches

== Custom Claim Mapping

To handle non-standard token claims, implement custom `ClaimMapper` instances:

[source,java]
----
// Create custom mapper for non-standard "role" claim
ClaimMapper roleMapper = new JsonCollectionMapper();

IssuerConfig issuerConfig = IssuerConfig.builder()
    .issuerIdentifier("https://issuer.com")
    .jwksContent(jwksContent)
    .claimMapper("role", roleMapper)  // Register custom mapper
    .build();
----

Built-in mappers include:

* `JsonCollectionMapper` - Handles JSON arrays and strings
* `StringSplitterMapper` - Splits delimited strings
* `IdentityMapper` - Returns values unchanged

== Integration Points

=== Pipeline Customization

The validation pipeline consists of:

. `NonValidatingJwtParser` - Basic JWT parsing
. `TokenHeaderValidator` - Header validation
. `TokenSignatureValidator` - Signature verification
. `TokenClaimValidator` - Claims validation

Each validator throws `TokenValidationException` with specific `EventType` on failure.

== Testing Support

The library provides comprehensive test utilities via the `generators` artifact. See xref:UnitTesting.adoc[Unit Testing Guide] for details.

== Thread Safety

* `TokenValidator` is thread-safe after construction
* `SecurityEventCounter` uses atomic operations
* `TokenValidatorMonitor` uses lock-free ring buffers
* JWKS loaders handle concurrent key refresh

== Performance Considerations

* Signature validation typically consumes 90%+ of validation time
* Use `TokenValidatorMonitor` to identify bottlenecks
* Configure appropriate JWKS refresh intervals (300-3600 seconds)
* Consider token caching for frequently validated tokens

=== Access Token Cache

The library provides built-in caching for validated access tokens to improve performance:

[source,java]
----
// Configure access token caching
AccessTokenCacheConfig cacheConfig = AccessTokenCacheConfig.builder()
    .maxSize(500)  // Maximum number of tokens to cache
    .evictionIntervalSeconds(300L)  // Time between cache cleanups
    .build();

// Or disable caching entirely
AccessTokenCacheConfig disabledCache = AccessTokenCacheConfig.disabled();

// Use with TokenValidator
TokenValidator validator = TokenValidator.builder()
    .issuerConfig(issuerConfig)
    .cacheConfig(cacheConfig)  // Optional, defaults to maxSize=1000
    .build();
----

Cache behavior:

* Set `maxSize` to 0 or use `AccessTokenCacheConfig.disabled()` to disable caching
* Default configuration caches up to 1000 tokens with 300-second eviction interval
* LRU eviction when cache reaches capacity
* Automatic cleanup of expired tokens

== Memory Management

Configure limits in `ParserConfig` to prevent attacks:

* `maxTokenSize` - Limits entire JWT token (default 8KB)
* `maxPayloadSize` - Limits decoded parts (default 2KB)
* `maxStringSize` - Limits JSON strings (default 1KB)
* `maxArraySize` - Limits array elements (default 64)
* `maxDepth` - Limits JSON nesting (default 10)

== Related Documentation

* xref:../README.adoc[README] - Usage examples and configuration
* xref:../../doc/specification/technical-components.adoc[Technical Components] - Architecture details
* xref:UnitTesting.adoc[Unit Testing Guide] - Test utilities documentation