/*
 * Copyright Â© 2025 CUI-OpenSource-Software (info@cuioss.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.cuioss.jwt.validation.pipeline;

import de.cuioss.jwt.validation.ParserConfig;
import de.cuioss.jwt.validation.TokenType;
import de.cuioss.jwt.validation.security.SecurityEventCounter;
import de.cuioss.jwt.validation.security.SignatureAlgorithmPreferences;
import de.cuioss.jwt.validation.test.InMemoryKeyMaterialHandler;
import de.cuioss.jwt.validation.test.TestTokenHolder;
import de.cuioss.jwt.validation.test.generator.ClaimControlParameter;
import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.nio.charset.StandardCharsets;
import java.security.Signature;
import java.util.Base64;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;

/**
 * Integration test that reproduces the ES256 signature format incompatibility issue.
 * <p>
 * This test demonstrates the current failure when validating ES256 tokens that use
 * IEEE P1363 signature format (as generated by Keycloak) vs the ASN.1/DER format
 * expected by the JDK ECDSA verification.
 * <p>
 * The test creates ES256 tokens with IEEE P1363 signature format and verifies that
 * the current implementation fails with signature format errors.
 */
class TokenSignatureValidatorES256FormatTest {

    private TokenSignatureValidator validator;

    @BeforeEach
    void setUp() {
        SecurityEventCounter securityEventCounter = new SecurityEventCounter();
        var jwksLoader = InMemoryKeyMaterialHandler.createJwksLoader(
                InMemoryKeyMaterialHandler.Algorithm.ES256,
                InMemoryKeyMaterialHandler.DEFAULT_KEY_ID,
                securityEventCounter
        );
        validator = new TokenSignatureValidator(jwksLoader, securityEventCounter, new SignatureAlgorithmPreferences());
    }

    @Test
    @DisplayName("ES256 IEEE P1363 format signatures should now work with format conversion")
    void es256IeeeP1363FormatNowWorks() {
        // This test verifies that ES256 signatures in IEEE P1363 format now work correctly
        // with the implemented signature format conversion

        // Create a token with ES256 algorithm that generates IEEE P1363 format signatures
        var tokenHolder = new TestTokenHolder(TokenType.ACCESS_TOKEN, ClaimControlParameter.defaultForTokenType(TokenType.ACCESS_TOKEN))
                .withES256IeeeP1363Format();

        // Create a manually crafted JWT with IEEE P1363 signature format
        var decodedJwt = createES256TokenWithIeeeP1363Signature(tokenHolder);

        // This should now work with format conversion
        assertDoesNotThrow(() -> {
            validator.validateSignature(decodedJwt);
        });
    }

    @Test
    @DisplayName("JJWT-generated ES256 tokens now work with format conversion")
    void jjwtES256TokensNowWork() {
        // JJWT generates IEEE P1363 format signatures, and with format conversion implemented,
        // these tokens should now validate successfully

        var tokenHolder = new TestTokenHolder(TokenType.ACCESS_TOKEN, ClaimControlParameter.defaultForTokenType(TokenType.ACCESS_TOKEN))
                .withES256IeeeP1363Format();

        var decodedJwt = tokenHolder.asDecodedJwt();

        // This should now work with the implemented format conversion
        assertDoesNotThrow(() -> {
            validator.validateSignature(decodedJwt);
        });
    }

    /**
     * Creates an ES256 JWT token with IEEE P1363 signature format.
     * This simulates how Keycloak generates ES256 signatures.
     */
    private DecodedJwt createES256TokenWithIeeeP1363Signature(TestTokenHolder tokenHolder) {
        try {
            // Get the key material
            var privateKey = InMemoryKeyMaterialHandler.getPrivateKey(
                    InMemoryKeyMaterialHandler.Algorithm.ES256,
                    InMemoryKeyMaterialHandler.DEFAULT_KEY_ID
            );

            // Create header and payload
            String header = "{\"alg\":\"ES256\",\"typ\":\"JWT\",\"kid\":\"" +
                    InMemoryKeyMaterialHandler.DEFAULT_KEY_ID + "\"}";
            String payload = createPayloadFromToken(tokenHolder);

            String headerEncoded = Base64.getUrlEncoder().withoutPadding()
                    .encodeToString(header.getBytes(StandardCharsets.UTF_8));
            String payloadEncoded = Base64.getUrlEncoder().withoutPadding()
                    .encodeToString(payload.getBytes(StandardCharsets.UTF_8));

            String dataToSign = headerEncoded + "." + payloadEncoded;

            // Create signature in IEEE P1363 format (raw R,S concatenation)
            var signature = Signature.getInstance("SHA256withECDSA");
            signature.initSign(privateKey);
            signature.update(dataToSign.getBytes(StandardCharsets.UTF_8));
            byte[] asn1Signature = signature.sign();

            // Convert ASN.1/DER signature to IEEE P1363 format
            byte[] ieeeP1363Signature = convertAsn1ToIeeeP1363(asn1Signature);

            String signatureEncoded = Base64.getUrlEncoder().withoutPadding()
                    .encodeToString(ieeeP1363Signature);

            String completeJwt = dataToSign + "." + signatureEncoded;
            String[] parts = completeJwt.split("\\.");

            // Parse header and payload back to Maps using DSL-JSON
            var dslJson = ParserConfig.builder().build().getDslJson();
            @SuppressWarnings("unchecked") Map<String, Object> headerJson = (Map<String, Object>) dslJson.deserialize(
                    Map.class, header.getBytes(), header.length());
            @SuppressWarnings("unchecked") Map<String, Object> payloadJson = (Map<String, Object>) dslJson.deserialize(
                    Map.class, payload.getBytes(), payload.length());

            JsonObject headerJsonObject = convertMapToJsonObject(headerJson);
            JsonObject payloadJsonObject = convertMapToJsonObject(payloadJson);
            return new DecodedJwt(headerJsonObject, payloadJsonObject, signatureEncoded, parts, completeJwt);

        } catch (Exception e) {
            throw new IllegalStateException("Failed to create IEEE P1363 format ES256 token", e);
        }
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private static JsonObject convertMapToJsonObject(Map<String, Object> map) {
        var builder = Json.createObjectBuilder();
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            addValueToBuilder(builder, entry.getKey(), entry.getValue());
        }
        return builder.build();
    }

    private static void addValueToBuilder(JsonObjectBuilder builder, String key, Object value) {
        if (value == null) {
            builder.addNull(key);
        } else if (value instanceof String string) {
            builder.add(key, string);
        } else if (value instanceof Boolean boolean1) {
            builder.add(key, boolean1);
        } else if (value instanceof Number number) {
            if (value instanceof Integer integer) {
                builder.add(key, integer);
            } else if (value instanceof Long long1) {
                builder.add(key, long1);
            } else {
                builder.add(key, number.doubleValue());
            }
        } else if (value instanceof List list) {
            // Convert List to JsonArray
            var arrayBuilder = Json.createArrayBuilder();
            for (Object item : list) {
                if (item == null) {
                    arrayBuilder.addNull();
                } else if (item instanceof String string) {
                    arrayBuilder.add(string);
                } else if (item instanceof Boolean boolean1) {
                    arrayBuilder.add(boolean1);
                } else if (item instanceof Number number) {
                    if (item instanceof Integer integer) {
                        arrayBuilder.add(integer);
                    } else if (item instanceof Long long1) {
                        arrayBuilder.add(long1);
                    } else {
                        arrayBuilder.add(number.doubleValue());
                    }
                } else if (item instanceof Map map) {
                    // Convert nested Map to JsonObject
                    var nestedBuilder = Json.createObjectBuilder();
                    for (Object entryObj : map.entrySet()) {
                        var entry = (Map.Entry) entryObj;
                        addValueToBuilder(nestedBuilder, entry.getKey().toString(), entry.getValue());
                    }
                    arrayBuilder.add(nestedBuilder.build());
                } else {
                    arrayBuilder.add(item.toString());
                }
            }
            builder.add(key, arrayBuilder.build());
        } else if (value instanceof Map map) {
            // Convert nested Map to JsonObject
            var nestedBuilder = Json.createObjectBuilder();
            for (Object entryObj : map.entrySet()) {
                var entry = (Map.Entry) entryObj;
                addValueToBuilder(nestedBuilder, entry.getKey().toString(), entry.getValue());
            }
            builder.add(key, nestedBuilder.build());
        } else {
            // For other types, convert to string as fallback
            builder.add(key, value.toString());
        }
    }

    /**
     * Creates a JSON payload string from the token holder's claims.
     */
    private String createPayloadFromToken(TestTokenHolder tokenHolder) {
        // Get the existing JWT token and extract the payload
        String rawToken = tokenHolder.getRawToken();
        String[] parts = rawToken.split("\\.");
        if (parts.length < 2) {
            throw new IllegalStateException("Invalid JWT token format");
        }

        // Decode the payload part
        byte[] payloadBytes = Base64.getUrlDecoder().decode(parts[1]);
        return new String(payloadBytes, StandardCharsets.UTF_8);
    }

    /**
     * Converts ASN.1/DER ECDSA signature to IEEE P1363 format.
     * This is a simplified conversion for ES256 (P-256 curve).
     */
    @SuppressWarnings("java:S125")
    private byte[] convertAsn1ToIeeeP1363(byte[] asn1Signature) throws Exception {
        // Parse ASN.1 DER structure: SEQUENCE { r INTEGER, s INTEGER }
        // This is a simplified parser for the specific case

        int index = 0;
        if (asn1Signature[index++] != 0x30) { // SEQUENCE tag
            throw new IllegalArgumentException("Invalid ASN.1 signature format");
        }

        index++; // Skip length byte

        // Parse R
        if (asn1Signature[index++] != 0x02) { // INTEGER tag
            throw new IllegalArgumentException("Invalid R component");
        }

        int rLength = asn1Signature[index++] & 0xFF;
        byte[] rBytes = new byte[32]; // ES256 uses 32 bytes for R
        System.arraycopy(asn1Signature, index + Math.max(0, rLength - 32),
                rBytes, Math.max(0, 32 - rLength),
                Math.min(32, rLength));
        index += rLength;

        // Parse S
        if (asn1Signature[index++] != 0x02) { // INTEGER tag
            throw new IllegalArgumentException("Invalid S component");
        }

        int sLength = asn1Signature[index++] & 0xFF;
        byte[] sBytes = new byte[32]; // ES256 uses 32 bytes for S
        System.arraycopy(asn1Signature, index + Math.max(0, sLength - 32),
                sBytes, Math.max(0, 32 - sLength),
                Math.min(32, sLength));

        // Concatenate R and S for IEEE P1363 format
        byte[] result = new byte[64]; // 32 + 32 for ES256
        System.arraycopy(rBytes, 0, result, 0, 32);
        System.arraycopy(sBytes, 0, result, 32, 32);

        return result;
    }
}