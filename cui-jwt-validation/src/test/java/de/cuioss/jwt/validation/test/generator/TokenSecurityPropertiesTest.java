/**
 * Copyright Â© 2025 CUI-OpenSource-Software (info@cuioss.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.cuioss.jwt.validation.test.generator;

import de.cuioss.jwt.validation.jwks.JwksLoader;
import de.cuioss.jwt.validation.jwks.key.KeyInfo;
import de.cuioss.jwt.validation.security.SecurityEventCounter;
import de.cuioss.jwt.validation.test.InMemoryJWKSFactory;
import de.cuioss.test.generator.junit.EnableGeneratorController;
import de.cuioss.test.juli.junit5.EnableTestLogger;
import de.cuioss.tools.logging.CuiLogger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.Base64;
import java.util.List;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for the security properties of generated tokens.
 * <p>
 * These tests verify that tokens generated by the test utilities use strong
 * cryptographic algorithms and have enough entropy to resist cracking attempts.
 * <p>
 * What is tested:
 * <ul>
 *   <li>Tokens use strong cryptographic algorithms (RS256, RS384, RS512, ES256, ES384, ES512, PS256, PS384, PS512)</li>
 *   <li>Tokens have sufficient entropy in their header and payload</li>
 *   <li>Only approved algorithms are used</li>
 *   <li>Token signatures are unpredictable</li>
 * </ul>
 */
@EnableTestLogger
@DisplayName("Token Security Properties Tests")
@EnableGeneratorController
class TokenSecurityPropertiesTest {

    private static final CuiLogger LOGGER = new CuiLogger(TokenSecurityPropertiesTest.class);

    private JwksLoader jwksLoader;

    @BeforeEach
    void setUp() {
        SecurityEventCounter securityEventCounter = new SecurityEventCounter();
        jwksLoader = InMemoryJWKSFactory.createDefaultJwksLoader(securityEventCounter);
    }

    @Test
    @DisplayName("Tokens should use strong cryptographic algorithms")
    void tokensShouldUseStrongCryptographicAlgorithms() {
        // Use the JwksLoader created in setUp

        // Get all key infos
        List<KeyInfo> keyInfos = jwksLoader.getAllKeyInfos();
        assertFalse(keyInfos.isEmpty(), "JwksLoader should contain keys");

        // Check each key's algorithm to ensure it's strong
        for (KeyInfo keyInfo : keyInfos) {
            String algorithm = keyInfo.getAlgorithm();

            // Verify that the algorithm is not a weak one
            assertNotEquals("none", algorithm, "Algorithm should not be 'none'");
            assertNotEquals("HS1", algorithm, "Algorithm should not be HS1");
            assertNotEquals("HS256", algorithm, "Algorithm should not be HS256 (prefer RS256 or ES256)");

            // Verify that the algorithm is a strong one
            assertTrue(
                    "RS256".equals(algorithm) ||
                            "RS384".equals(algorithm) ||
                            "RS512".equals(algorithm) ||
                            "ES256".equals(algorithm) ||
                            "ES384".equals(algorithm) ||
                            "ES512".equals(algorithm) ||
                            "PS256".equals(algorithm) ||
                            "PS384".equals(algorithm) ||
                            "PS512".equals(algorithm),
                    "Algorithm should be a strong one, but was: " + algorithm
            );
        }
    }

    @Test
    @DisplayName("Tokens should have sufficient entropy")
    void tokensShouldHaveSufficientEntropy() {
        // Generate a token
        String token = TestTokenGenerators.accessTokens().next().getRawToken();

        // Split the token into its parts
        String[] parts = token.split("\\.");
        assertEquals(3, parts.length, "Token should have 3 parts");

        // Check the header and payload for entropy
        String header = parts[0];
        String payload = parts[1];
        String signature = parts[2];

        // Decode the header and payload
        byte[] headerBytes = Base64.getUrlDecoder().decode(header);
        byte[] payloadBytes = Base64.getUrlDecoder().decode(payload);

        // Calculate entropy using Shannon entropy formula
        double headerEntropy = calculateShannonEntropy(headerBytes);
        double payloadEntropy = calculateShannonEntropy(payloadBytes);

        // Verify that the entropy is sufficient
        assertTrue(headerEntropy > 3.0, "Header entropy should be > 3.0, but was: " + headerEntropy);
        assertTrue(payloadEntropy > 4.0, "Payload entropy should be > 4.0, but was: " + payloadEntropy);

        // Verify that the signature is sufficiently long
        assertTrue(signature.length() >= 32, "Signature should be at least 32 characters long");
    }

    @ParameterizedTest
    @ValueSource(strings = {"RS256", "RS384", "RS512", "ES256", "ES384", "ES512"})
    @DisplayName("Tokens should use approved algorithms")
    void tokensShouldUseApprovedAlgorithms(String algorithm) {
        // Use the JwksLoader created in setUp

        // Get all key infos
        List<KeyInfo> keyInfos = jwksLoader.getAllKeyInfos();

        // Check if any key uses the specified algorithm
        boolean algorithmFound = keyInfos.stream()
                .anyMatch(keyInfo -> keyInfo.getAlgorithm().equals(algorithm));

        // If the algorithm is not found, log a warning but don't fail the test
        // as the test environment might not have all algorithms configured
        if (!algorithmFound) {
            LOGGER.warn("Algorithm " + algorithm + " not found in the JWKS");
        }

        // Verify that the algorithm is in the list of approved algorithms
        Set<String> approvedAlgorithms = Set.of("RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "PS256", "PS384", "PS512");
        assertTrue(approvedAlgorithms.contains(algorithm), "Algorithm should be in the list of approved algorithms");
    }

    @Test
    @DisplayName("Tokens should have unpredictable signatures")
    void tokensShouldHaveUnpredictableSignatures() {
        // Generate multiple tokens
        String token1 = TestTokenGenerators.accessTokens().next().getRawToken();
        String token2 = TestTokenGenerators.accessTokens().next().getRawToken();
        String token3 = TestTokenGenerators.accessTokens().next().getRawToken();

        // Split the tokens into their parts
        String[] parts1 = token1.split("\\.");
        String[] parts2 = token2.split("\\.");
        String[] parts3 = token3.split("\\.");

        // Get the signatures
        String signature1 = parts1[2];
        String signature2 = parts2[2];
        String signature3 = parts3[2];

        // Verify that the signatures are different
        assertNotEquals(signature1, signature2, "Signatures should be different");
        assertNotEquals(signature1, signature3, "Signatures should be different");
        assertNotEquals(signature2, signature3, "Signatures should be different");
    }

    /**
     * Calculates the Shannon entropy of a byte array.
     * 
     * @param bytes the byte array
     * @return the Shannon entropy
     */
    private double calculateShannonEntropy(byte[] bytes) {
        if (bytes.length == 0) {
            return 0.0;
        }

        // Count the frequency of each byte value
        int[] counts = new int[256];
        for (byte b : bytes) {
            counts[b & 0xFF]++;
        }

        // Calculate the Shannon entropy
        double entropy = 0.0;
        for (int count : counts) {
            if (count > 0) {
                double probability = (double)count / bytes.length;
                entropy -= probability * (Math.log(probability) / Math.log(2));
            }
        }

        return entropy;
    }
}
