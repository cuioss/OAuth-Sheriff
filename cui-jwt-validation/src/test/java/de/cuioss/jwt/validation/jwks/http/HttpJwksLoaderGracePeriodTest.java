/*
 * Copyright Â© 2025 CUI-OpenSource-Software (info@cuioss.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.cuioss.jwt.validation.jwks.http;

import de.cuioss.jwt.validation.jwks.key.KeyInfo;
import de.cuioss.jwt.validation.security.SecurityEventCounter;
import de.cuioss.jwt.validation.test.InMemoryJWKSFactory;
import de.cuioss.jwt.validation.test.dispatcher.JwksResolveDispatcher;
import de.cuioss.test.juli.junit5.EnableTestLogger;
import de.cuioss.test.mockwebserver.EnableMockWebServer;
import de.cuioss.test.mockwebserver.URIBuilder;
import lombok.Getter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.Optional;

import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static org.awaitility.Awaitility.await;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for Issue #110: Key rotation grace period functionality.
 * Tests configuration validation and grace period behavior with real HTTP endpoints.
 *
 * @author Oliver Wolff
 * @see <a href="https://github.com/cuioss/cui-jwt/issues/110">Issue #110</a>
 */
@EnableTestLogger
@EnableMockWebServer
@DisplayName("Tests HttpJwksLoader Key Rotation Grace Period Implementation (Issue #110)")
class HttpJwksLoaderGracePeriodTest {

    private static final String ORIGINAL_KEY_ID = InMemoryJWKSFactory.DEFAULT_KEY_ID;
    private static final String ROTATED_KEY_ID = "alternative-key-id";

    @Getter
    private final JwksResolveDispatcher moduleDispatcher = new JwksResolveDispatcher();

    private SecurityEventCounter securityEventCounter;

    @BeforeEach
    void setUp() {
        moduleDispatcher.setCallCounter(0);
        moduleDispatcher.returnDefault();
        securityEventCounter = new SecurityEventCounter();
    }

    @Test
    @DisplayName("Should use default grace period of 5 minutes")
    void shouldUseDefaultGracePeriodOf5Minutes() {
        HttpJwksLoaderConfig config = HttpJwksLoaderConfig.builder()
                .jwksUrl("https://example.com/jwks")
                .issuerIdentifier("test-issuer")
                .build(); // No explicit grace period - should use default

        assertEquals(Duration.ofMinutes(5), config.getKeyRotationGracePeriod(),
                "Default grace period should be 5 minutes as per Issue #110");
        assertEquals(3, config.getMaxRetiredKeySets(),
                "Default max retired key sets should be 3");
    }

    @Test
    @DisplayName("Should allow custom grace period configuration")
    void shouldAllowCustomGracePeriodConfiguration() {
        HttpJwksLoaderConfig config = HttpJwksLoaderConfig.builder()
                .jwksUrl("https://example.com/jwks")
                .issuerIdentifier("test-issuer")
                .keyRotationGracePeriod(Duration.ofMinutes(10))
                .maxRetiredKeySets(5)
                .build();

        assertEquals(Duration.ofMinutes(10), config.getKeyRotationGracePeriod(),
                "Custom grace period should be configurable");
        assertEquals(5, config.getMaxRetiredKeySets(),
                "Custom max retired key sets should be configurable");
    }

    @Test
    @DisplayName("Should allow zero grace period to disable feature")
    void shouldAllowZeroGracePeriodToDisableFeature() {
        HttpJwksLoaderConfig config = HttpJwksLoaderConfig.builder()
                .jwksUrl("https://example.com/jwks")
                .issuerIdentifier("test-issuer")
                .keyRotationGracePeriod(Duration.ZERO)
                .build();

        assertEquals(Duration.ZERO, config.getKeyRotationGracePeriod(),
                "Zero grace period should be allowed to disable the feature");
    }

    @Test
    @DisplayName("Configuration should be accessible via getters")
    void configurationShouldBeAccessibleViaGetters() {
        HttpJwksLoaderConfig config = HttpJwksLoaderConfig.builder()
                .jwksUrl("https://example.com/jwks")
                .issuerIdentifier("test-issuer")
                .keyRotationGracePeriod(Duration.ofMinutes(5))
                .maxRetiredKeySets(3)
                .build();

        // Test that the getters work (they should be generated by Lombok)
        assertEquals(Duration.ofMinutes(5), config.getKeyRotationGracePeriod());
        assertEquals(3, config.getMaxRetiredKeySets());
    }

    @Test
    @DisplayName("Should immediately invalidate retired keys with zero grace period after rotation")
    void shouldImmediatelyInvalidateRetiredKeysWithZeroGracePeriod(URIBuilder uriBuilder) {
        String jwksEndpoint = uriBuilder.addPathSegment(JwksResolveDispatcher.LOCAL_PATH).buildAsString();

        HttpJwksLoaderConfig config = HttpJwksLoaderConfig.builder()
                .jwksUrl(jwksEndpoint)
                .issuerIdentifier("test-issuer")
                .keyRotationGracePeriod(Duration.ZERO) // Zero grace period - should immediately invalidate retired keys
                .refreshIntervalSeconds(1) // Enable background refresh for key rotation
                .build();

        HttpJwksLoader loader = new HttpJwksLoader(config);
        loader.initJWKSLoader(securityEventCounter).join();

        // Initial load - should find the original key
        moduleDispatcher.returnDefault();
        Optional<KeyInfo> originalKey = loader.getKeyInfo(ORIGINAL_KEY_ID);
        assertTrue(originalKey.isPresent(), "Original key should be found initially");

        // Rotate keys - switch to different key
        moduleDispatcher.switchToOtherPublicKey();

        // Wait for key rotation to complete
        await("Key rotation to complete")
                .atMost(2000, MILLISECONDS)
                .until(() -> {
                    Optional<KeyInfo> newKey = loader.getKeyInfo(ROTATED_KEY_ID);
                    return newKey.isPresent();
                });

        // New key should be accessible
        Optional<KeyInfo> rotatedKey = loader.getKeyInfo(ROTATED_KEY_ID);
        assertTrue(rotatedKey.isPresent(), "Rotated key should be found in current keys");

        // With zero grace period, original key should immediately be inaccessible
        // This verifies the timing bug fix - the key should be properly retired and immediately cleaned up
        Optional<KeyInfo> retiredKey = loader.getKeyInfo(ORIGINAL_KEY_ID);
        assertFalse(retiredKey.isPresent(),
                "Original key should NOT be accessible with zero grace period after rotation. " +
                        "This verifies the timing bug fix works correctly.");

        loader.close();
    }

    @Test
    @DisplayName("Should keep retired keys accessible within grace period")
    void shouldKeepRetiredKeysAccessibleWithinGracePeriod(URIBuilder uriBuilder) {
        String jwksEndpoint = uriBuilder.addPathSegment(JwksResolveDispatcher.LOCAL_PATH).buildAsString();

        HttpJwksLoaderConfig config = HttpJwksLoaderConfig.builder()
                .jwksUrl(jwksEndpoint)
                .issuerIdentifier("test-issuer")
                .keyRotationGracePeriod(Duration.ofMinutes(5)) // 5 minute grace period
                .refreshIntervalSeconds(1) // Enable background refresh for key rotation
                .build();

        HttpJwksLoader loader = new HttpJwksLoader(config);
        loader.initJWKSLoader(securityEventCounter).join();

        // Initial load - should find the original key
        moduleDispatcher.returnDefault();
        Optional<KeyInfo> originalKey = loader.getKeyInfo(ORIGINAL_KEY_ID);
        assertTrue(originalKey.isPresent(), "Original key should be found initially");

        // Rotate keys - switch to different key
        moduleDispatcher.switchToOtherPublicKey();

        // Wait for key rotation to complete
        await("Key rotation to complete")
                .atMost(2000, MILLISECONDS)
                .until(() -> {
                    Optional<KeyInfo> newKey = loader.getKeyInfo(ROTATED_KEY_ID);
                    return newKey.isPresent();
                });

        // Both keys should be accessible: current key and retired key within grace period
        Optional<KeyInfo> rotatedKey = loader.getKeyInfo(ROTATED_KEY_ID);
        assertTrue(rotatedKey.isPresent(), "Current rotated key should be accessible");

        Optional<KeyInfo> retiredKey = loader.getKeyInfo(ORIGINAL_KEY_ID);
        assertTrue(retiredKey.isPresent(),
                "Original key should still be accessible within 5-minute grace period. " +
                        "This verifies the grace period mechanism works correctly.");

        loader.close();
    }

    @Test
    @DisplayName("Should validate negative grace period is not allowed")
    @SuppressWarnings("java:S5778") // Single lambda invocation - validation happens in setter
    void shouldValidateNegativeGracePeriodIsNotAllowed() {
        assertThrows(IllegalArgumentException.class, () ->
                HttpJwksLoaderConfig.builder()
                        .jwksUrl("https://example.com/jwks")
                        .issuerIdentifier("test-issuer")
                        .keyRotationGracePeriod(Duration.ofMinutes(-1))
        );
    }

    @Test
    @DisplayName("Should validate maxRetiredKeySets is positive")
    void shouldValidateMaxRetiredKeySetsIsPositive() {
        var baseBuilder = HttpJwksLoaderConfig.builder()
                .jwksUrl("https://example.com/jwks")
                .issuerIdentifier("test-issuer");

        assertThrows(IllegalArgumentException.class,
                () -> baseBuilder.maxRetiredKeySets(0));

        var anotherBuilder = HttpJwksLoaderConfig.builder()
                .jwksUrl("https://example.com/jwks")
                .issuerIdentifier("test-issuer");

        assertThrows(IllegalArgumentException.class,
                () -> anotherBuilder.maxRetiredKeySets(-1));
    }
}