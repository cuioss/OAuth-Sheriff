= GraalVM Cryptographic Performance Analysis
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

== Executive Summary

**Analysis Date**: January 2026 +
**Context**: JWT validation performance in GraalVM native images +
**Primary Finding**: RSA signature verification performs excellently at 68µs - no optimization needed

=== Key Findings

* **RSA Performance**: 68µs per signature verification (JMH measured)
* **CPU Impact**: BigInteger.modPow() accounts for only 1% of CPU samples (JFR verified)
* **Historical Correction**: Previous claims of 230ms RSA overhead were based on incorrect benchmarks
* **Recommendation**: No algorithm migration urgently needed - RSA performance is excellent

== Historical Context

=== July 2025 Investigation

Previous documentation reported:

* Total JWT Validation: 265.9ms P95
* RSA Signature Verification: ~230ms (claimed 97% of overhead)
* BigInteger.modPow() identified as primary bottleneck

=== January 2026 Verification

JMH microbenchmarks and JFR profiling reveal:

* Total JWT Library Processing: 77µs
* RSA Signature Verification: 68µs (88% of library time)
* Integration endpoint latency: 1.91ms P50

**Root Cause of Discrepancy**: The July 2025 benchmarks had flawed methodology - likely measuring cold start, excessive object allocation, or broken test infrastructure rather than steady-state RSA performance.

== Current RSA Performance

=== JMH Benchmark Results

[cols="2,2,2", options="header"]
|===
| Operation | Time | Notes

| RSA-256 Signature Verification
| 68µs
| Using default JDK provider

| Full JWT Parsing + Verification
| 77µs
| Includes JSON parsing

| Token Cache Lookup
| 0.1µs
| Lock-free concurrent cache
|===

=== JFR CPU Profiling

JFR analysis of 48,027 execution samples under load:

[cols="2,2,2", options="header"]
|===
| Component | Stack Frames | Percentage

| TLS Encryption (AES-GCM, SHA)
| 43,055
| **89.6%**

| Netty I/O
| 39,952
| 83.2%

| CDI Container
| 30,070
| 62.6%

| Vert.x Event Loop
| 24,003
| 50.0%

| JOSE/JWT Processing
| 787
| 1.6%

| BigInteger (RSA)
| 501
| **1.0%**
|===

NOTE: Percentages overlap due to nested stack frames. The key insight: **BigInteger operations are negligible (1%)** while **TLS encryption dominates (89.6%)**.

== GraalVM Native Image Characteristics

=== Performance Model

Native images trade JIT optimization for startup speed and memory efficiency:

* **No JIT Compilation**: Static AOT compilation
* **Predictable Performance**: No warmup period
* **Consistent Latency**: No JIT deoptimization spikes

=== Cryptographic Performance in Native Images

Contrary to earlier assumptions:

* BigInteger operations are NOT significantly degraded in native images
* The default JDK RSA provider performs well at 68µs
* Native image cryptographic performance is production-ready

=== GraalVM 25 / Mandrel jdk-25 Improvements

* **WP-SCCP**: Whole-Program Sparse Conditional Constant Propagation (enabled by default)
* **ML Profile Inference**: GraalNN provides 1-3% performance boost
* **JCMD Support**: Native images now support runtime diagnostics via jcmd
* **Vector API**: Initial optimization support for vectorized operations

== Algorithm Comparison

=== JOSE Algorithm Performance Characteristics

[cols="2,2,2,3", options="header"]
|===
| Algorithm | Type | Measured Time | Assessment

| RS256
| RSA 2048-bit
| 68µs
| ✅ Excellent - current default

| ES256
| ECDSA P-256
| ~20-40µs (estimated)
| Faster, marginal benefit

| Ed25519
| EdDSA Curve25519
| ~10-20µs (estimated)
| Fastest, smaller signatures
|===

=== Migration Cost-Benefit

With RSA at 68µs (88% of 77µs library processing, 3.5% of 1.91ms total latency):

* **ECDSA Migration**: ~30-50µs savings = 1.5-2.5% latency reduction
* **EdDSA Migration**: ~50-60µs savings = 2.5-3% latency reduction

**Verdict**: Algorithm migration provides marginal improvement. Decision should be driven by standards compliance, key management, and token size requirements rather than performance.

== JCA Provider Landscape

=== Default JDK Provider (Recommended)

* **Performance**: 68µs RSA - excellent
* **Compatibility**: Full native image support
* **Maintenance**: Automatic updates with JDK
* **Assessment**: ✅ Use for most deployments

=== BouncyCastle

* **Status**: Available for specialized algorithm support
* **Use Case**: When default JDK doesn't support required algorithm
* **Native Image**: Requires reflection configuration
* **Assessment**: Use only if specific algorithms needed

=== Conscrypt (Google)

* **Status**: Not recommended for native images
* **Issues**: BoringSSL dynamic library dependencies
* **Assessment**: ❌ Not suitable for GraalVM native image

=== Jipher (Oracle)

* **Status**: No longer bundled with GraalVM 25
* **Availability**: Separate download from Oracle
* **Use Case**: FIPS 140-2 compliance requirements
* **Assessment**: Consider only for regulated environments

== Recommendations

=== For Most Deployments

1. **Use default JDK provider** - RSA at 68µs is excellent
2. **Keep RS256** - Standard, well-supported, adequate performance
3. **No urgent optimization needed** - Current performance exceeds targets

=== When to Consider Algorithm Migration

* **Token size matters**: EdDSA signatures are smaller
* **New deployment**: Opportunity to standardize on modern algorithms
* **Identity provider supports it**: Check Keycloak/provider algorithm support

=== When to Consider Alternative Providers

* **FIPS compliance required**: Evaluate Jipher (separate download)
* **Specific algorithm needed**: BouncyCastle for extended algorithm support

== Performance Monitoring

=== JFR for Production

With GraalVM 25, JFR can be controlled at runtime:

[source,bash]
----
# Build with monitoring support
native-image --enable-monitoring=jcmd,jfr,heapdump YourApp

# At runtime, start recording
jcmd <pid> JFR.start duration=60s filename=profile.jfr

# Dump recording
jcmd <pid> JFR.dump filename=profile.jfr
----

=== Key Metrics to Monitor

* RSA verification time (should remain ~68µs)
* BigInteger CPU percentage (should remain ~1%)
* TLS overhead (expected to dominate at 80-90%)

== Related Documents

* xref:jwt-validation-performance.adoc[JWT Validation Performance] - Overall performance baselines
* xref:jfr-profiling-guide.adoc[JFR Profiling Guide] - How to collect profiling data
* xref:graalvm-enterprise-optimization-options.adoc[Enterprise Optimization Options] - Commercial options
* link:../../../benchmarking/doc/Analysis-01.2026-JFR-Profiling.adoc[JFR Profiling Analysis] - Detailed CPU hotspot data
